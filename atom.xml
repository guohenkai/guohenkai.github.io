<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ghk&#39;s Blog</title>
  <subtitle>(*@ο@*~) show me the code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://guohenkai.github.io/"/>
  <updated>2022-10-17T09:42:51.696Z</updated>
  <id>https://guohenkai.github.io/</id>
  
  <author>
    <name>郭恒开</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node服务端框架Egg.js</title>
    <link href="https://guohenkai.github.io/2022/10/16/Node%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%86%E6%9E%B6Egg.js/"/>
    <id>https://guohenkai.github.io/2022/10/16/Node服务端框架Egg.js/</id>
    <published>2022-10-15T16:00:00.000Z</published>
    <updated>2022-10-17T09:42:51.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h1><p>Egg是一款由阿里团队开源的nodejs服务端框架，框架内置多进程管理，插件高度可扩展。能够很大程度的降低团队的开发成本。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>● 约定优于配置<br>● 一个插件只做一件事<br> <a id="more"></a></p>
<h1 id="和其他框架的差异"><a href="#和其他框架的差异" class="headerlink" title="和其他框架的差异"></a>和其他框架的差异</h1><p>● Express: 缺少框架上的约定，随着时间和功能的迭代，团队协作成本越来越高。<br>● koa： 由express原班团队打造，egg基于koa框架之上，egg约定了一些配置和规则，进一步对koa进行了一些增强。<br>● Sails： Sails内部集成了众多插件，egg不提供插件功能，由用户自行选择</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//初始化package.json</div><div class="line">npm init</div><div class="line"></div><div class="line">//安装egg框架核心模块</div><div class="line">npm install egg --save</div><div class="line"></div><div class="line">//安装egg框架命令行工具</div><div class="line">npm install egg-bin --save-dev</div></pre></td></tr></table></figure>
<h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//常用初始化</div><div class="line">npm init egg --type=simple</div><div class="line"></div><div class="line">//完整初始化安装一个egg项目</div><div class="line">npm init egg</div><div class="line"></div><div class="line">//安装框架依赖</div><div class="line">npm install</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>egg框架的全局配置在根目录下的config文件夹下： /config/</p>
<h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>● 默认配置： config.default.js<br>● 线上环境：config.prod.js<br>● 本地开发:：config.local.js<br>● 测试环境:：config.test.js<br>● 单元测试：config.unittest,js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">//示例</div><div class="line"></div><div class="line">const config = exports;</div><div class="line"></div><div class="line">//中间件列表声明</div><div class="line">config.middleware = [ &apos;authentication&apos; ];</div><div class="line">//中间件配置</div><div class="line">config.authentication = &#123;</div><div class="line">  //是否启用</div><div class="line">  enable: true,</div><div class="line">  //不适用该中间件的规则</div><div class="line">  ignore: [ &apos;/api/user/login&apos;, ctx =&gt; &#123;</div><div class="line">    if (ctx.path === &apos;/api/version&apos; &amp;&amp; ctx.request.method.toUpperCase() === &apos;POST&apos;) &#123;</div><div class="line">      return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">  &#125; ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//本地开发调试server配置</div><div class="line">config.cluster = &#123;</div><div class="line">  listen: &#123;</div><div class="line">    port: 8089,</div><div class="line">    hostname: &apos;0.0.0.0&apos;,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//mysql服务器配置</div><div class="line">config.mysql = &#123;</div><div class="line">  client: &#123;</div><div class="line">    host: &apos;&apos;,</div><div class="line">    port: &apos;&apos;,</div><div class="line">    user: &apos;&apos;,</div><div class="line">    password: &apos;&apos;,</div><div class="line">    database: &apos;&apos;,</div><div class="line">  &#125;,</div><div class="line">  app: true,</div><div class="line">  agent: false,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//redis服务器配置</div><div class="line">config.redis = &#123;</div><div class="line">  client: &#123;</div><div class="line">    port: 6379,</div><div class="line">    host: &apos;127.0.0.1&apos;,</div><div class="line">    password: &apos;&apos;,</div><div class="line">    db: 0,</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">//http请求配置</div><div class="line">config.httpclient = &#123;</div><div class="line">  request: &#123;</div><div class="line">    timeout: 10000,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//跨域请求配置</div><div class="line">config.cors = &#123;</div><div class="line">  origin: &apos;*&apos;,</div><div class="line">  allowMethods: &apos;GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS&apos;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//HTTP访问安全配置</div><div class="line">config.security = &#123;</div><div class="line">  csrf: &#123;</div><div class="line">    enable: false,</div><div class="line">  &#125;,</div><div class="line">  domainWhiteList: [ &apos;*&apos; ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//日志配置</div><div class="line">config.logger = &#123;</div><div class="line">  dir: path.join(appInfo.baseDir, &apos;logs&apos;),</div><div class="line">  appLogName: `$&#123;appInfo.name&#125;-web.log`,</div><div class="line">  coreLogName: &apos;core.log&apos;,</div><div class="line">  agentLogName: &apos;agent.log&apos;,</div><div class="line">  errorLogName: &apos;error.log&apos;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><blockquote>
<p>详细文档地址：<a href="https://eggjs.org/zh-cn/basics/plugin.html" target="_blank" rel="external">https://eggjs.org/zh-cn/basics/plugin.html</a><br>插件开发文档地址： <a href="https://eggjs.org/zh-cn/advanced/plugin.html" target="_blank" rel="external">https://eggjs.org/zh-cn/advanced/plugin.html</a></p>
</blockquote>
<p>● plugin.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//示例</div><div class="line"></div><div class="line">/**</div><div class="line">* mysql的配置</div><div class="line">* enable: 是否启用</div><div class="line">* package: 插件的安装包包名</div><div class="line">*/</div><div class="line">exports.mysql = &#123;</div><div class="line">  enable: true,</div><div class="line">  package: &apos;egg-mysql&apos;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/**</div><div class="line">* 跨域配置插件</div><div class="line">* enable: 是否启用</div><div class="line">* package: 插件的安装包包名</div><div class="line">*/</div><div class="line">exports.cors = &#123;</div><div class="line">  enable: true,</div><div class="line">  package: &apos;egg-cors&apos;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/**</div><div class="line">* redis的配置</div><div class="line">* enable: 是否启用</div><div class="line">* package: 插件的安装包包名</div><div class="line">*/</div><div class="line">exports.redis = &#123;</div><div class="line">  enable: true,</div><div class="line">  package: &apos;egg-redis&apos;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="配置加载顺序"><a href="#配置加载顺序" class="headerlink" title="配置加载顺序"></a>配置加载顺序</h3><p>从环境上区分：</p>
<ol>
<li>default</li>
<li>prod</li>
</ol>
<p>从组件类型上区分：</p>
<ol>
<li>插件</li>
<li>框架</li>
<li>应用</li>
</ol>
<p>规则：先加载环境，也就是所有default，然后加载prod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//示例</div><div class="line">-&gt; 插件 config.default.js</div><div class="line">-&gt; 框架 config.default.js</div><div class="line">-&gt; 应用 config.default.js</div><div class="line">-&gt; 插件 config.prod.js</div><div class="line">-&gt; 框架 config.prod.js</div><div class="line">-&gt; 应用 config.prod.js</div></pre></td></tr></table></figure></p>
<h3 id="配置内置对象"><a href="#配置内置对象" class="headerlink" title="配置内置对象"></a>配置内置对象</h3><p>配置也可以使用回调函数，来接收一个appInfo对象，获取应用自身的一些配置信息，appInfo对象有以下属性：</p>
<p>● pkg: package.json对象<br>● name: package.json的属性name，即配置的应用名<br>● baseDir: 应用的代码根目录<br>● HOME: 用户在系统中的目录地址<br>● root：本地和测试时指向baseDir,其它环境指向HOME<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//示例用法</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">module.exports = appInfo =&gt; &#123;</div><div class="line">  return &#123;</div><div class="line">    logger: &#123;</div><div class="line">      dir: path.join(appInfo.baseDir, &apos;logs&apos;),</div><div class="line">    &#125;,</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="目录结构和约定"><a href="#目录结构和约定" class="headerlink" title="目录结构和约定"></a>目录结构和约定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">egg-project</div><div class="line">├── package.json //项目配置描述文件</div><div class="line">├── app.js (可选) //项目入口文件</div><div class="line">├── agent.js (可选)//agent进程入口文件</div><div class="line">├── app //项目源代码目录</div><div class="line">|   ├── router.js //路由配置文件</div><div class="line">│   ├── controller //controller层目录，用于解析用户的输入，处理后返回相应的结果</div><div class="line">│   |   └── home.js</div><div class="line">│   ├── service (可选)//service层目录，用于编写业务逻辑层</div><div class="line">│   |   └── user.js</div><div class="line">│   ├── middleware (可选) //中间件目录</div><div class="line">│   |   └── response_time.js</div><div class="line">│   ├── schedule (可选) //定时任务目录</div><div class="line">│   |   └── my_task.js</div><div class="line">│   ├── public (可选)//用于放置静态资源</div><div class="line">│   |   └── reset.css</div><div class="line">│   ├── view (可选) //SSR，服务端渲染模板目录</div><div class="line">│   |   └── home.tpl</div><div class="line">│   └── extend (可选)//框架扩展文件目录</div><div class="line">│       ├── helper.js (可选)</div><div class="line">│       ├── request.js (可选)</div><div class="line">│       ├── response.js (可选)</div><div class="line">│       ├── context.js (可选)</div><div class="line">│       ├── application.js (可选)</div><div class="line">│       └── agent.js (可选)</div><div class="line">├── config //项目配置目录，关于插件配置，环境配置，单元测试配置等都在此目录</div><div class="line">|   ├── plugin.js</div><div class="line">|   ├── config.default.js</div><div class="line">│   ├── config.prod.js</div><div class="line">|   ├── config.test.js (可选)</div><div class="line">|   ├── config.local.js (可选)</div><div class="line">|   └── config.unittest.js (可选)</div><div class="line">└── test//单元测试目录</div><div class="line">    ├── middleware</div><div class="line">    |   └── response_time.test.js</div><div class="line">    └── controller</div><div class="line">        └── home.test.js</div></pre></td></tr></table></figure>
<h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><h3 id="启动自定义"><a href="#启动自定义" class="headerlink" title="启动自定义"></a>启动自定义</h3><blockquote>
<p>有点类似前端框架的生命周期，在生命周期函数中可以做一些事<br>配置地址：app.js中定义</p>
</blockquote>
<p>● configWillLoad: 配置文件即将加载<br>● configDidLoad: 配置文件加载完成<br>● didLoad:文件加载完成<br>● willReady: 插件启动完毕<br>● didReady: worker 准备就绪<br>● serverDidReady:应用启动完成<br>● beforeClose:应用即将关闭</p>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><blockquote>
<p>详细文档：<a href="https://eggjs.org/zh-cn/basics/objects.html" target="_blank" rel="external">https://eggjs.org/zh-cn/basics/objects.html</a></p>
</blockquote>
<p>● application: app<br>● Context: ctx<br>● Request: ctx.request<br>● Response: ctx.response<br>● Controller: 基础类<br>● Service: 基础类<br>● Helper: ctx.helper<br>● Config: app.config<br>● Logger: ctx.logger || app.logger</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="声明规则"><a href="#声明规则" class="headerlink" title="声明规则"></a>声明规则</h4><p>router.verb(‘router-name’, ‘path-match’, ‘middleware1’, … , ‘middlewareN’, app.controller.action);<br>● router：路由对象，从全局内置对象app中解构出来<br>● verb: HTTP请求的类型，有【head,get,post,put,delete,redirect】<br>● router-name: 给路由声明一个别名，可选配置，大多场景不需要配置<br>● path-match：接口或服务的路由地址<br>● middleware：给这个路由单独指定的一些中间件名称<br>● controller： Controller层的函数名，也可以简写为字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//app/router.js</div><div class="line">module.exports = app =&gt; &#123;</div><div class="line">  const &#123; router, controller &#125; = app;</div><div class="line">  router.get(&apos;/user/:id&apos;, controller.user.info);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="RESTFUL通配符"><a href="#RESTFUL通配符" class="headerlink" title="RESTFUL通配符"></a>RESTFUL通配符</h4><p>路由中可以使用变量，用通配符占位，在context对象中可以接收。<br>路由的定义也可以使用正则表达式来声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">例如路由：&apos;/user/:id&apos;</div><div class="line">匹配地址：&apos;/user/1264542&apos;</div><div class="line"></div><div class="line">//在controller层的ctx.params.id就可以获取道路由中的id参数</div><div class="line">const &#123; id &#125; = ctx.params;</div><div class="line">console.log(id); // 1264542</div></pre></td></tr></table></figure></p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><blockquote>
<p>详细文档： <a href="https://eggjs.org/zh-cn/basics/controller.html" target="_blank" rel="external">https://eggjs.org/zh-cn/basics/controller.html</a></p>
</blockquote>
<p>Router 将用户的请求基于 method 和 URL 分发到了对应的 Controller 上， Controller 负责解析用户的输入，处理后返回相应的结果。请求参数进行处理（校验、转换），然后调用对应的 service 方法处理业务，得到业务结果后封装并返回</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>● 接口中，Controller 接受用户的参数，从数据库中查找内容返回给用户或者将用户的请求更新到数据库中<br>● HTML 页面请求中，Controller 根据用户访问不同的 URL，渲染不同的模板得到 HTML 返回给用户<br>● 代理服务，将用户的请求转发到其他服务器上，并将其他服务器的处理结果返回给用户</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// app/controller/post.js</div><div class="line"></div><div class="line">//引入egg框架的Controller对象</div><div class="line">const Controller = require(&apos;egg&apos;).Controller;</div><div class="line"></div><div class="line">//声明一个继承框架Controller的类</div><div class="line">class PostController extends Controller &#123;</div><div class="line">    </div><div class="line">    async create() &#123;</div><div class="line">        const &#123; ctx, service &#125; = this;</div><div class="line">        const createRule = &#123;</div><div class="line">            title: &#123; type: &apos;string&apos; &#125;,</div><div class="line">            content: &#123; type: &apos;string&apos; &#125;,</div><div class="line">        &#125;;</div><div class="line">        // 校验参数</div><div class="line">        ctx.validate(createRule);</div><div class="line">        </div><div class="line">        // 组装参数</div><div class="line">        const author = ctx.session.userId;</div><div class="line">        const req = Object.assign(ctx.request.body, &#123; author &#125;);</div><div class="line">        </div><div class="line">        // 调用 Service 进行业务处理</div><div class="line">        const res = await service.post.create(req);</div><div class="line">        </div><div class="line">        // 设置响应内容和响应状态码</div><div class="line">        ctx.body = &#123; id: res.id &#125;;</div><div class="line">        ctx.status = 201;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = PostController;</div></pre></td></tr></table></figure>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><blockquote>
<p>详细文档：<a href="https://eggjs.org/zh-cn/basics/service.html" target="_blank" rel="external">https://eggjs.org/zh-cn/basics/service.html</a></p>
</blockquote>
<p>Service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，他的目的是：<br>● 保持 Controller 中的逻辑更加简洁<br>● 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用<br>● 将逻辑和展现分离，更容易编写测试用例</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>● 复杂数据的处理，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。或者计算完成后，更新到数据库。<br>● 第三方服务的调用，比如 GitHub 信息获取等</p>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// app/service/post.js</div><div class="line">const Service = require(&apos;egg&apos;).Service;</div><div class="line"></div><div class="line">class PostService extends Service &#123;</div><div class="line">    </div><div class="line">  async create(params) &#123;</div><div class="line">      const &#123; ctx, app &#125; = this;</div><div class="line">      const result = await app.mysql.insert(&apos;posts&apos;, params);</div><div class="line">      </div><div class="line">      if (result.affectedRows !== 1) &#123;</div><div class="line">          ctx.logger.error(&apos;Create error : %j.&apos;, fields);</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return true;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = PostService;</div></pre></td></tr></table></figure>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><blockquote>
<p>详细文档： <a href="https://eggjs.org/zh-cn/core/logger.html" target="_blank" rel="external">https://eggjs.org/zh-cn/core/logger.html</a></p>
</blockquote>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>● appLogger： 应用相关日志<br>● coreLogger：框架内核、插件日志<br>● errorLogger ： 日志中.error API生成的日志都在这里<br>● agentLogger ：agent 进程日志</p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// config/config.default.js</div><div class="line">const path = require(&apos;path&apos;)</div><div class="line">module.exports = appInfo =&gt; &#123;</div><div class="line">    const config = exports;</div><div class="line">    </div><div class="line">    config.logger = &#123;</div><div class="line">        dir: path.join(appInfo.baseDir, &apos;logs&apos;), // 根目录下的logs目录下</div><div class="line">        appLogName: `$&#123;appInfo.name&#125;-web.log`, // 应用运行时产生的日志</div><div class="line">        coreLogName: &apos;core.log&apos;, // 框架日志</div><div class="line">        agentLogName: &apos;agent.log&apos;, // agent线程日志</div><div class="line">        errorLogName: &apos;error.log&apos;, // 异常错误日志</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h4><p>● debug： 开发调试时打印的一些日志<br>● info： 应用运行中一些关键信息记录<br>● wanr： 一些警告、提醒类的日志<br>● error： 程序错误、业务逻辑错误、异常捕获到的错误</p>
<h4 id="动态日志"><a href="#动态日志" class="headerlink" title="动态日志"></a>动态日志</h4><p>● %s: 为一个字符串占位，动态显示一些变量数据在日志字符串中的占位符<br>● %j: 为一个对象或者数组占位，动态显示一些变量数据在日志字符串中的占位符<br>● %d: 为一个数字占位，动态显示一些变量数据在日志字符串中的占位符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ctx.logger.error(&apos;接口请求错误，状态码:%d, 错误原因: %s, 错误数据：%j&apos;, 502, &apos;sql执行错误&apos;, &#123;data: &#123;a: 2&#125;&#125;)</div><div class="line"></div><div class="line">//输出：接口请求错误，状态码:502, 错误原因: sql执行错误, 错误数据：&#123;data: &#123;a: 2&#125;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>详细文档：<a href="https://eggjs.org/zh-cn/basics/extend.html" target="_blank" rel="external">https://eggjs.org/zh-cn/basics/extend.html</a></p>
</blockquote>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>在项目根目录下app/extend/目录中可以d对框架的内置对象进行扩展封装。</p>
<p>● Application： app/extend/application.js<br>● Context： app/extend/context.js<br>● Request:  app/extend/request.js<br>● Response:  app/extend/response.js<br>● Helper:  app/extend/helper.js</p>
<blockquote>
<p>也可以根据环境来声明特定环境才会生效的扩展：app/extend/application.local.js</p>
</blockquote>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">//app/extend/application.js</div><div class="line">module.exports = &#123;</div><div class="line">    test (params) &#123;</div><div class="line">        // 这里的this指向app对象</div><div class="line">    &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用方式</div><div class="line">app.test(&#123;a: 1&#125;);</div><div class="line"></div><div class="line"></div><div class="line">//app/extend/context.js</div><div class="line">module.exports = &#123;</div><div class="line">    test (params) &#123;</div><div class="line">        // 这里的this指向ctx对象</div><div class="line">    &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用方式</div><div class="line">ctx.test(&#123;a: 1&#125;);</div><div class="line"></div><div class="line"></div><div class="line">//app/extend/request.js</div><div class="line">module.exports = &#123;</div><div class="line">    test (params) &#123;</div><div class="line">        // 这里的this指向ctx.request对象</div><div class="line">    &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用方式</div><div class="line">ctx.request.test(&#123;a: 1&#125;);</div><div class="line"></div><div class="line"></div><div class="line">//app/extend/response.js</div><div class="line">module.exports = &#123;</div><div class="line">    test (params) &#123;</div><div class="line">        // 这里的this指向ctx.response对象</div><div class="line">    &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用方式</div><div class="line">ctx.response.test(&#123;a: 1&#125;);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//app/extend/helper.js</div><div class="line">module.exports = &#123;</div><div class="line">    test (params) &#123;</div><div class="line">        // 这里的this指向Helper内置对象</div><div class="line">    &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用方式</div><div class="line">ctx.helper.test(&#123;a: 1&#125;);</div><div class="line">app.helper.test(&#123;a: 1&#125;);</div></pre></td></tr></table></figure>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><blockquote>
<p><a href="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" target="_blank" rel="external">https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67</a></p>
</blockquote>
<p>Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。每次我们编写一个中间件，就相当于在洋葱外面包了一层</p>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><h5 id="中间件的通用配置属性："><a href="#中间件的通用配置属性：" class="headerlink" title="中间件的通用配置属性："></a>中间件的通用配置属性：</h5><p>● enable：控制中间件是否开启。<br>● match：设置只有符合某些规则的请求才会经过这个中间件。<br>● ignore：设置符合某些规则的请求不经过这个中间件。</p>
<h5 id="根据环境在框架中配置"><a href="#根据环境在框架中配置" class="headerlink" title="根据环境在框架中配置"></a>根据环境在框架中配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// config/config.[env].js中配置</div><div class="line">module.exports = &#123;</div><div class="line">  </div><div class="line">  // 配置需要的中间件，数组顺序即为中间件的加载顺序</div><div class="line">  middleware: [ &apos;gzip&apos; ],</div><div class="line">  // 配置 gzip 中间件的自定义配置</div><div class="line">  gzip: &#123;</div><div class="line">    threshold: 1024, // 小于 1k 的响应体不压缩</div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="路由中配置"><a href="#路由中配置" class="headerlink" title="路由中配置"></a>路由中配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// app/router.js中</div><div class="line">module.exports = app =&gt; &#123;</div><div class="line">  const gzip = app.middleware.gzip(&#123; threshold: 1024 &#125;);</div><div class="line">  app.router.get(&apos;/needgzip&apos;, gzip, app.controller.handler);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="开发示例"><a href="#开发示例" class="headerlink" title="开发示例"></a>开发示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// middleware/gzip.js</div><div class="line">const isJSON = require(&apos;koa-is-json&apos;);</div><div class="line">const zlib = require(&apos;zlib&apos;);</div><div class="line"></div><div class="line">async function gzip(ctx, next) &#123;</div><div class="line">  await next();</div><div class="line"></div><div class="line">  // 后续中间件执行完成后将响应体转换成 gzip</div><div class="line">  let body = ctx.body;</div><div class="line">  if (!body) return;</div><div class="line">  if (isJSON(body)) body = JSON.stringify(body);</div><div class="line"></div><div class="line">  // 设置 gzip body，修正响应头</div><div class="line">  const stream = zlib.createGzip();</div><div class="line">  stream.end(body);</div><div class="line">  ctx.body = stream;</div><div class="line">  ctx.set(&apos;Content-Encoding&apos;, &apos;gzip&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line">* 需要接收中间件自定义配置参数时</div><div class="line">* 使用函数封装中间件，入参配置</div><div class="line">*/</div><div class="line">module.exports = options =&gt; &#123;</div><div class="line">  return async function gzip(ctx, next) &#123;</div><div class="line">    //options为app.config.gzip的值</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="HTTP-Client"><a href="#HTTP-Client" class="headerlink" title="HTTP Client"></a>HTTP Client</h3><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;框架介绍&quot;&gt;&lt;a href=&quot;#框架介绍&quot; class=&quot;headerlink&quot; title=&quot;框架介绍&quot;&gt;&lt;/a&gt;框架介绍&lt;/h1&gt;&lt;p&gt;Egg是一款由阿里团队开源的nodejs服务端框架，框架内置多进程管理，插件高度可扩展。能够很大程度的降低团队的开发成本。&lt;/p&gt;
&lt;h1 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h1&gt;&lt;p&gt;● 约定优于配置&lt;br&gt;● 一个插件只做一件事&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="https://guohenkai.github.io/categories/Node/"/>
    
    
      <category term="egg.js" scheme="https://guohenkai.github.io/tags/egg-js/"/>
    
  </entry>
  
  <entry>
    <title>微前端的技术方案</title>
    <link href="https://guohenkai.github.io/2022/09/25/%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <id>https://guohenkai.github.io/2022/09/25/微前端的技术方案/</id>
    <published>2022-09-24T16:00:00.000Z</published>
    <updated>2022-10-17T10:01:54.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>随着大数据行业的高速发展，传统的ToB领域产品，几乎都会面临业务快速发展之后，单体应用进化成巨石应用的问题：如随着业务越来越多，单体应用的模块、文件、组件也越来越多，随之而来的就是打包、编译速度越来越慢，开发人员的介入也越来越多，代码维护起来就会越来越难，更重要的是无法进行增量升级，只能全量升级等等一系列的问题。</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78frf2i7gj20lu09vjuz.jpg" alt="image.png"></p>
 <a id="more"></a>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>将前端应用分解成一些更小、更简单的能够分团队进行独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品，各子应用可自由组合，适配不同的客户群体。</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78fsern7yj20vg0a3go9.jpg" alt="image.png"></p>
<h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><p>目前国内微前端的主流的技术实现方案主要有Ifram,组合式集成、web components、ESM、emp、基座模式</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78ft0osvmj21bo0hcdqb.jpg" alt="image.png"></p>
<h4 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h4><p>是传统的微前端解决方案，基于iframe标签实现，技术难度低，隔离性和兼容性很好，但是性能和使用体验比较差，多用于集成第三方系统；</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78ftgtbsgj20ov0a5q41.jpg" alt="image.png"></p>
<p><strong>iframe大家都知道，他的一个兼容性和隔离性是特别好的，天生的就支持了样式、js隔离，但是它的使用体验是不太好的：</strong></p>
<ol>
<li>页面加载问题<br>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载，阻塞 onload 事件。每次点击都需要重新加载，虽然可以采用 display:none 来做缓存，但是页面缓存过多会导致电脑卡顿。</li>
<li>布局问题<br>iframe 必须给一个指定的高度，否则会塌陷。</li>
<li>弹窗及遮罩层问题<br>弹窗只能在 iframe 范围内垂直水平居中，没法在整个页面垂直水平居中</li>
<li>浏览器前进/后退问题<br>iframe 和主页面共用一个浏览历史，iframe 会影响页面的前进后退。大部分时候正常，iframe 多次重定向则会导致浏览器的前进后退功能无法正常使用</li>
<li>iframe 加载失败的情况不好处理<br>非同源的 iframe 在火狐及 chorme 都不支持 onerror 事件。</li>
<li>每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程，占用大量资源的同时也在极大地消耗资源</li>
<li>iframe的特性导致搜索引擎无法获取到其中的内容，进而无法实现应用的seo</li>
</ol>
<h4 id="组合式集成"><a href="#组合式集成" class="headerlink" title="组合式集成"></a>组合式集成</h4><p>微应用化，即在开发时，应用都是以单一、微小应用的形式存在，而在运行时，则通过构建系统合并这些应用，组合成一个新的应用。</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78ftvcnvnj20hu0c1dgz.jpg" alt="image.png"></p>
<p><strong>组合式集成，即通过软件工程的方式在构建前、构建时、构建后等步骤中，对应用进行一步的拆分，并重新组合。</strong></p>
<h5 id="常见的方式有："><a href="#常见的方式有：" class="headerlink" title="常见的方式有："></a>常见的方式有：</h5><p>● 独立构建组件和应用，生成 chunk 文件，构建后再归类生成的 chunk 文件。（这种方式更类似于微服务，但是成本更高）<br>● 开发时独立开发组件或应用，集成时合并组件和应用，最后生成单体的应用。<br>● 在运行时，加载应用的 Runtime，随后加载对应的应用代码和模板。</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>● 统一依赖。统一这些依赖的版本，引入新的依赖时都需要一一加入。<br>● 规范应用的组件及路由。避免不同的应用之间，因为这些组件名称发生冲突。<br>● 构建复杂。在有些方案里，我们需要修改构建系统，有些方案里则需要复杂的架构脚本。<br>● 共享通用代码。这显然是一个要经常面对的问题。<br>● 制定代码规范。</p>
<h4 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h4><p>Web Components 是一套不同的技术，允许开发者创建可重用的定制元素（它们的功能封装在代码之外），并且在 Web 应用中使用它们。</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78fu7rmrnj20ny0csac8.jpg" alt="image.png"></p>
<p><strong>Web Components是Web组件模型标准，由浏览器提供原生特性支持，包括Shadow DOM，Custom Elements，HTML Imports和HTML Templates</strong></p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>天生的样式、js隔离，</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1、上下游生态系统不完善。缺乏相应的一些第三方控件支持<br>2、需要重构现有的前端应用<br>3、Web Components 触发的事件可能无法通过 React 渲染树正确的传递。 你需要在 React 组件中手动添加事件处理器来处理这些事件。</p>
<h5 id="目前困扰"><a href="#目前困扰" class="headerlink" title="目前困扰"></a>目前困扰</h5><p>Web Components 技术推广的主要因素，在于浏览器的支持程度。在 Chrome 和 Opera 浏览器上，对于 Web Components 支持良好，而对于 Safari、IE、Firefox 浏览器的支持程度，并没有那么理想。</p>
<h4 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h4><p><strong>ESM是ES Module的缩写，是Ecma script 2015中提出的一种前端模块化手段</strong></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><ol>
<li>无技术栈限制：ESM加载的只是js内容，无论哪个框架，最终都要编译成js，因此，无论哪种框架，ESM都能加载。</li>
<li>应用单独开发： ESM只是js的一种规范，不会影响应用的开发模式。</li>
<li>多应用整合： 只要将微应用以ESM的方式暴露出来，就能正常加载。</li>
<li>远程加载模块: ESM能够直接请求cdn资源，这是它与生俱来的能力。</li>
</ol>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>兼容性问题</p>
<h4 id="EMP"><a href="#EMP" class="headerlink" title="EMP"></a>EMP</h4><p>使用指南：<a href="https://github.com/efoxTeam/emp/wiki" target="_blank" rel="external">https://github.com/efoxTeam/emp/wiki</a></p>
<p><strong>EMP是由欢聚时代业务中台自主研发的最年轻的单页微前端解决方案，基于Webpack5 Module Federation，一种去中心化的微前端实现方案，它不仅能很好地隔离应用，还可以轻松实现应用间的资源共享和通信</strong></p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78fv0nhsdj20ku0axjvq.jpg" alt="image.png"></p>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><p>● 基于Webpack5的新特性Module Federation实现，达到第三方依赖共享，减少不必要的代码引入的目的，什么是Module Federation这里就不再赘述。<br>● 每个微应用独立部署运行，并通过cdn的方式引入主程序中，因此只需要部署一次，便可以提供给任何基于Module Federation的应用使用。并且此部分代码是远程引入，无需参与应用的打包。<br>● 动态更新微应用：EMP是通过cdn加载微应用，因此每个微应用中的代码有变动时，无需重新打包发布新的整合应用便能加载到最新的微应用。<br>● 去中心化，每个微应用间都可以引入其他的微应用，无中心应用的概念。<br>● 跨技术栈组件式调用，提供了在主应用框架中可以调用其他框架组件的能力（目前已支持互相调用的框架及使用方式请参阅官方文档）。<br>● 按需加载，开发者可以选择只加载微应用中需要的部分，而不是强制只能将整个应用全部加载。<br>● 应用间通信，每一个应用都可以进行状态共享，就像在使用npm模块进行开发一样便捷。<br>● 生成对应技术栈模板，它能像create-react-app一样，也能像create-vue-app一样，通过指令一键搭建好开发环境，减少开发者的负担。<br>● 远程拉取ts声明文件，emp-cli中内置了拉取远程应用中代码声明文件的能力，让使用ts开发的开发者不再为代码报错而烦恼。</p>
<h4 id="基座模式"><a href="#基座模式" class="headerlink" title="基座模式"></a>基座模式</h4><h5 id="SingleSpa"><a href="#SingleSpa" class="headerlink" title="SingleSpa"></a>SingleSpa</h5><p><strong>SingleSpa是一个javascript库，它让很多小页面、小组件、不同架构的前端组件在一个页面应用程序中共存。</strong></p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78fvngp1uj20ia0byta3.jpg" alt="image.png"></p>
<p>single-spa 约定了应用、包的生命周期，并调度着应用、包生命周期周转（路由匹配机制）的流程。至于应用、包的加载函数、路由匹配策略及其生命周期函数则由开发者手动实现。基座本身只提供生命周期规范。</p>
<h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><ol>
<li>配置复杂</li>
<li>一定的资源浪费<br> 由于核心逻辑还是在于请求manifest，拿到js文件后执行渲染，这个过程不可避免会产生一些冗余，对于C端的应用来说，这个问题比较致命，当然，对于B端来说，这个是可以接受的，在可控制的范围之内</li>
</ol>
<h5 id="qiankun"><a href="#qiankun" class="headerlink" title="qiankun"></a>qiankun</h5><p>官网：<a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="external">https://qiankun.umijs.org/zh/guide</a></p>
<p>参考文档：<a href="https://www.jianshu.com/p/3484415c8a00；https://www.jianshu.com/p/009785740345" target="_blank" rel="external">https://www.jianshu.com/p/3484415c8a00；https://www.jianshu.com/p/009785740345</a></p>
<p><strong>qiankun（乾坤） 就是一款由蚂蚁金服推出的比较成熟的微前端框架，基于 single-spa 进行二次开发，用于将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用</strong></p>
<h6 id="在微前端界，qiankun算得上是最早成型且知名度最广的框架了，它是真正意义上的单页微前端框架，其主要特点是："><a href="#在微前端界，qiankun算得上是最早成型且知名度最广的框架了，它是真正意义上的单页微前端框架，其主要特点是：" class="headerlink" title="在微前端界，qiankun算得上是最早成型且知名度最广的框架了，它是真正意义上的单页微前端框架，其主要特点是："></a>在微前端界，qiankun算得上是最早成型且知名度最广的框架了，它是真正意义上的单页微前端框架，其主要特点是：</h6><p>● 基于single-spa封装，提供了更加开箱即用的 API<br>● 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架<br>● HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单<br>● 样式隔离，确保微应用之间样式互相不干扰<br>● JS 沙箱，确保微应用之间 全局变量/事件 不冲突<br>● 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度<br>● umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78fw50ix1j20vo0dfq77.jpg" alt="image.png"></p>
<h5 id="icestark"><a href="#icestark" class="headerlink" title="icestark"></a>icestark</h5><p>icestark内部维护了所有微应用的配置信息，包括路由规则、bundle 地址等，同时劫持了 window.history 相关的几个跳转事件，当捕获到页面跳转事件时，icestark会根据跳转的路由获取对应的微应用信息，然后跟之前的微应用信息进行对比，如果是同一个微应用，则什么都不做，如果是不同的微应用，则将前一个微应用的 bundle 卸载，同时加载新的微应用 bundle 资源，加载完成后微应用 bundle 会执行自身的渲染逻辑。</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78fwi05ahj20y407odij.jpg" alt="image.png"></p>
<p>参考文档： <a href="https://zhuanlan.zhihu.com/p/88449415" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/88449415</a></p>
<h5 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h5><p>● single-spa：社区公认的主流方案，可以基于它做二次开发<br>● qiankun：基于 single-spa 封装，增加 umi 特色，增加沙箱机制（JS、ShadowDOM 等）<br>● icestark：类似于 single-spa 实现，React 技术栈友好，阿里的另一个轮子</p>
<h3 id="技术方案对比"><a href="#技术方案对比" class="headerlink" title="技术方案对比"></a>技术方案对比</h3><table>
<thead>
<tr>
<th>方案</th>
<th>相对特点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>iFrame</td>
<td>天生隔离样式与脚本、多页</td>
<td>页面加载问题、布局问题 、弹窗及遮罩层问题、缺少通信机制等</td>
</tr>
<tr>
<td>Web Components</td>
<td>天生隔离样式与脚本</td>
<td>无法兼容所有浏览器，对老应用需要重构，子应用通信较为复杂易踩坑</td>
</tr>
<tr>
<td>ESM</td>
<td>远程加载模块</td>
<td>无法兼容所有浏览器(但可以通过编译工具解决)     需手动隔离样式（可通过css module解决）</td>
</tr>
<tr>
<td>EMP</td>
<td>去中心化、跨技术栈组件式调用、应用间通信 、远程拉取ts声明文件</td>
<td></td>
</tr>
<tr>
<td>基座模式</td>
<td>统一的基座管理HTML Entry、JS 接入方式 成熟的通信机制、路由机制等</td>
<td>需要对现有代码进行配置（需要添加生命周期钩子、配置）</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;现状&quot;&gt;&lt;a href=&quot;#现状&quot; class=&quot;headerlink&quot; title=&quot;现状&quot;&gt;&lt;/a&gt;现状&lt;/h3&gt;&lt;p&gt;随着大数据行业的高速发展，传统的ToB领域产品，几乎都会面临业务快速发展之后，单体应用进化成巨石应用的问题：如随着业务越来越多，单体应用的模块、文件、组件也越来越多，随之而来的就是打包、编译速度越来越慢，开发人员的介入也越来越多，代码维护起来就会越来越难，更重要的是无法进行增量升级，只能全量升级等等一系列的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/e0823b04ly1h78frf2i7gj20lu09vjuz.jpg&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术方案" scheme="https://guohenkai.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="微前端" scheme="https://guohenkai.github.io/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>实名认证和实人认证（阿里云）</title>
    <link href="https://guohenkai.github.io/2022/09/04/%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%E5%92%8C%E5%AE%9E%E4%BA%BA%E8%AE%A4%E8%AF%81/"/>
    <id>https://guohenkai.github.io/2022/09/04/实名认证和实人认证/</id>
    <published>2022-09-03T16:00:00.000Z</published>
    <updated>2022-10-17T09:44:26.767Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、云盾身份认证（身份证⼆要素）"><a href="#一、云盾身份认证（身份证⼆要素）" class="headerlink" title="一、云盾身份认证（身份证⼆要素）"></a>一、云盾身份认证（身份证⼆要素）</h4><h5 id="1-API-简单身份认证调用方法（APPCODE）"><a href="#1-API-简单身份认证调用方法（APPCODE）" class="headerlink" title="1.API 简单身份认证调用方法（APPCODE）"></a>1.API 简单身份认证调用方法（APPCODE）</h5><p>在线文档地址：<br><a href="https://netmarket.oss-cn-hangzhou.aliyuncs.com/d4da8cec89f643f8b785803f3ad90871.pdf?spm=5176.product-detail.detail.8.56bf40bdNH3pNT&amp;file=d4da8cec89f643f8b785803f3ad90871.pdf" target="_blank" rel="external">https://netmarket.oss-cn-hangzhou.aliyuncs.com/d4da8cec89f643f8b785803f3ad90871.pdf?spm=5176.product-detail.detail.8.56bf40bdNH3pNT&amp;file=d4da8cec89f643f8b785803f3ad90871.pdf</a><br> <a id="more"></a></p>
<h5 id="2-API-签名认证调用方法（AppKey-amp-AppSecret）"><a href="#2-API-签名认证调用方法（AppKey-amp-AppSecret）" class="headerlink" title="2.API 签名认证调用方法（AppKey &amp; AppSecret）"></a>2.API 签名认证调用方法（AppKey &amp; AppSecret）</h5><p>文档地址：<br><a href="https://help.aliyun.com/document_detail/157953.html?spm=5176.product-detail.detail.3.56bf40bdNH3pNT" target="_blank" rel="external">https://help.aliyun.com/document_detail/157953.html?spm=5176.product-detail.detail.3.56bf40bdNH3pNT</a></p>
<h4 id="二、活体检测"><a href="#二、活体检测" class="headerlink" title="二、活体检测"></a>二、活体检测</h4><h5 id="1-视频活体检测"><a href="#1-视频活体检测" class="headerlink" title="1.视频活体检测"></a>1.视频活体检测</h5><p>视频活体检测能力可以检测输入视频中的人脸来自直接拍摄还是翻拍。当视频中出现多个人脸时，对画面中面积最大的人脸进行判断，需要确保待检测人脸五官清晰可见。<br>文档地址：</p>
<p><a href="https://help.aliyun.com/document_detail/167847.html" target="_blank" rel="external">https://help.aliyun.com/document_detail/167847.html</a></p>
<h5 id="2-人脸活体检测"><a href="#2-人脸活体检测" class="headerlink" title="2.人脸活体检测"></a>2.人脸活体检测</h5><p>人脸活体检测能力可以检测图片中的活体对象（主要是人脸）来自直接拍摄或者是翻拍。活体判断的前置条件是图像中有人脸</p>
<p>文档地址：<br><a href="https://help.aliyun.com/document_detail/155006.html" target="_blank" rel="external">https://help.aliyun.com/document_detail/155006.html</a></p>
<h4 id="三、实人认证"><a href="#三、实人认证" class="headerlink" title="三、实人认证"></a>三、实人认证</h4><p>文档地址：<br><a href="https://help.aliyun.com/document_detail/173782.html" target="_blank" rel="external">https://help.aliyun.com/document_detail/173782.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、云盾身份认证（身份证⼆要素）&quot;&gt;&lt;a href=&quot;#一、云盾身份认证（身份证⼆要素）&quot; class=&quot;headerlink&quot; title=&quot;一、云盾身份认证（身份证⼆要素）&quot;&gt;&lt;/a&gt;一、云盾身份认证（身份证⼆要素）&lt;/h4&gt;&lt;h5 id=&quot;1-API-简单身份认证调用方法（APPCODE）&quot;&gt;&lt;a href=&quot;#1-API-简单身份认证调用方法（APPCODE）&quot; class=&quot;headerlink&quot; title=&quot;1.API 简单身份认证调用方法（APPCODE）&quot;&gt;&lt;/a&gt;1.API 简单身份认证调用方法（APPCODE）&lt;/h5&gt;&lt;p&gt;在线文档地址：&lt;br&gt;&lt;a href=&quot;https://netmarket.oss-cn-hangzhou.aliyuncs.com/d4da8cec89f643f8b785803f3ad90871.pdf?spm=5176.product-detail.detail.8.56bf40bdNH3pNT&amp;amp;file=d4da8cec89f643f8b785803f3ad90871.pdf&quot;&gt;https://netmarket.oss-cn-hangzhou.aliyuncs.com/d4da8cec89f643f8b785803f3ad90871.pdf?spm=5176.product-detail.detail.8.56bf40bdNH3pNT&amp;amp;file=d4da8cec89f643f8b785803f3ad90871.pdf&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="实人认证" scheme="https://guohenkai.github.io/categories/%E5%AE%9E%E4%BA%BA%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="阿里云" scheme="https://guohenkai.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>什么是微前端</title>
    <link href="https://guohenkai.github.io/2022/08/28/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    <id>https://guohenkai.github.io/2022/08/28/什么是微前端/</id>
    <published>2022-08-27T16:00:00.000Z</published>
    <updated>2022-10-17T10:05:42.173Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>现在很多企业，基本在物理上进行了应用代码隔离，实行单个应用单个库，闭环部署更新测试环境、预发布环境和正式环境。于是，我们的探讨的是，基于不同应用不同库并独立部署的情况下，如何实现多个应用之间的资源共享？</p>
<p>之前比较多的处理方式是npm包形式抽离和引用，比如多个应用项目之间，可能有某业务逻辑模块或者其他是可复用的，便抽离出来以npm包的形式进行管理和使用。但这样却带来了以下几个问题：</p>
<ul>
<li>发布效率低下。如果需要迭代npm包内的逻辑业务，需要先发布npm包之后，再每个使用了该npm包的应用都更新一次npm包版本，再各自构建发布一次，过程繁琐。如果涉及到的应用更多的话，花费的人力和精力就更多了。</li>
<li>多团队协作容易不规范。包含通用模块的npm包作为共享资产，“每个人”拥有它，但在实践中，这通常意味着没有人拥有它。它很快就会充满杂乱的风格不一致的代码，没有明确的约定或技术愿景。<a id="more"></a>
</li>
</ul>
<p>这些问题让我们意识到，扩展前端开发规模以便于多个团队可以同时开发一个大型且复杂的产品是一个重要但又棘手的难题。</p>
<p>微前端概念</p>
<p>Micro Frontends 官网定义了微前端概念：</p>
<blockquote>
<p>Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently.</p>
</blockquote>
<p>翻译成中文：构建一个现代web应用所需要的技术、策略和方法，具备多个团队独立开发、部署的特性。</p>
<p>从Micro Frontends 官网可以了解到，微前端概念是从微服务概念扩展而来的，摒弃大型单体方式，将前端整体分解为小而简单的块，这些块可以独立开发、测试和部署，同时仍然聚合为一个产品出现在客户面前。可以理解微前端是一种将多个可独立交付的小型前端应用聚合为一个整体的架构风格。</p>
<p>狭义的理解：微前端是一个工程使用多种框架，React + Vue + Jquery，解决多种框架共存的一个方案</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78fyx4kq6j20g20aj40q.jpg" alt="image"></p>
<h4 id="微前端优势"><a href="#微前端优势" class="headerlink" title="微前端优势"></a>微前端优势</h4><h5 id="同步更新"><a href="#同步更新" class="headerlink" title="同步更新"></a>同步更新</h5><p>微前端由于是多个子应用的聚合，如果多个业务应用依赖同一个服务应用的功能模块，只需要更新服务应用，其他业务应用就可以立马更新，从而缩短了更新流程和节约了更新成本。</p>
<h5 id="增量升级"><a href="#增量升级" class="headerlink" title="增量升级"></a>增量升级</h5><p>可维护性和扩展性更好，便于局部升级和增量升级</p>
<h5 id="简单、解耦的代码库"><a href="#简单、解耦的代码库" class="headerlink" title="简单、解耦的代码库"></a>简单、解耦的代码库</h5><p>代码库更小、内聚性更强、耦合性更低</p>
<h5 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署"></a>独立部署</h5><p>便于独立编译、测试和部署，可靠性更高</p>
<h5 id="自主的团队"><a href="#自主的团队" class="headerlink" title="自主的团队"></a>自主的团队</h5><p>各个团队可以独立开发，互不干扰</p>
<h4 id="微前端架构模式"><a href="#微前端架构模式" class="headerlink" title="微前端架构模式"></a>微前端架构模式</h4><p>目前国内微前端方案大概分为：</p>
<ul>
<li>基座模式：通过搭建基座、配置中心来管理子应用。如基于SIngle Spa的偏通用的qiankun方案，也有基于本身团队业务量身定制的方案。</li>
<li>自组织模式： 通过约定进行互调，但会遇到处理第三方依赖等问题。如system.js</li>
<li>去中心模式： 脱离基座模式，每个应用之间都可以彼此分享资源。如基于Webpack 5 Module Federation实现的EMP微前端方案，可以实现多个应用彼此共享资源分享。</li>
</ul>
<h5 id="基座模式"><a href="#基座模式" class="headerlink" title="基座模式"></a>基座模式</h5><p>主要基于路由分发，即由一个基座应用来监听路由，并按照路由规则来加载不同的应用，以实现应用间解耦；目前成熟的方案较多<br><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78fzn3jyvj20f709cjsk.jpg" alt="image.png"></p>
<h5 id="自组织模式"><a href="#自组织模式" class="headerlink" title="自组织模式"></a>自组织模式</h5><p>应用之间是平等的，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高<br><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78g05ao03j20hq0a20tn.jpg" alt="image.png"></p>
<h5 id="去中心模式"><a href="#去中心模式" class="headerlink" title="去中心模式"></a>去中心模式</h5><p>每个应用之间都可以彼此分享资源，也可以有公共的资源放在一个应用中管理，目前成熟的方案有EMP<br><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78g0hvsw6j20hh09p3zn.jpg" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;现在很多企业，基本在物理上进行了应用代码隔离，实行单个应用单个库，闭环部署更新测试环境、预发布环境和正式环境。于是，我们的探讨的是，基于不同应用不同库并独立部署的情况下，如何实现多个应用之间的资源共享？&lt;/p&gt;
&lt;p&gt;之前比较多的处理方式是npm包形式抽离和引用，比如多个应用项目之间，可能有某业务逻辑模块或者其他是可复用的，便抽离出来以npm包的形式进行管理和使用。但这样却带来了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布效率低下。如果需要迭代npm包内的逻辑业务，需要先发布npm包之后，再每个使用了该npm包的应用都更新一次npm包版本，再各自构建发布一次，过程繁琐。如果涉及到的应用更多的话，花费的人力和精力就更多了。&lt;/li&gt;
&lt;li&gt;多团队协作容易不规范。包含通用模块的npm包作为共享资产，“每个人”拥有它，但在实践中，这通常意味着没有人拥有它。它很快就会充满杂乱的风格不一致的代码，没有明确的约定或技术愿景。
    
    </summary>
    
      <category term="微前端" scheme="https://guohenkai.github.io/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="微前端" scheme="https://guohenkai.github.io/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用操作</title>
    <link href="https://guohenkai.github.io/2022/08/07/Git%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://guohenkai.github.io/2022/08/07/Git 常用操作/</id>
    <published>2022-08-06T16:00:00.000Z</published>
    <updated>2022-10-17T10:08:35.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、查看git提交记录"><a href="#1、查看git提交记录" class="headerlink" title="1、查看git提交记录"></a>1、查看git提交记录</h3><h4 id="查看详细的提交记录"><a href="#查看详细的提交记录" class="headerlink" title="查看详细的提交记录"></a>查看详细的提交记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure>
<h4 id="查看简略的提交记录"><a href="#查看简略的提交记录" class="headerlink" title="查看简略的提交记录"></a>查看简略的提交记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --oneline</div></pre></td></tr></table></figure>
 <a id="more"></a>
<p>输出如下，每条记录前面的随机字符传就是 commitId , 可用于检出checkout、回滚revert、回退reset等操作。</p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78g3hxglij20ku03smyw.jpg" alt="image"></p>
<h3 id="2、从之前的-commit-记录拉分支"><a href="#2、从之前的-commit-记录拉分支" class="headerlink" title="2、从之前的 commit 记录拉分支"></a>2、从之前的 commit 记录拉分支</h3><blockquote>
<p>使用说明: 例如 master 分支已经合并了新的代码，但是想要在上一个全量版本修改 bug 发版上线，需要从上个全量版本的 commit 记录拉分支修改后直接发线上。</p>
</blockquote>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ol>
<li>使用 git log –oneline 命令查询项目的提交记录</li>
<li>找到需要拉取的 commitId（注意别找错了）</li>
<li>使用如下命令即可从当前 commitId 拉分支。（f90622e8a 是 commitId，newBranch 是分支名称）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 第一种</div><div class="line">git checkout commitId -b newBranch </div><div class="line"># 第二种 </div><div class="line">git checkout -b newBranch f90622e8a</div></pre></td></tr></table></figure>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><blockquote>
<p>可以直观快捷的在 gitlab 上找到对应的提交记录进行操作</p>
</blockquote>
<ol>
<li>在 gitlab 上找到项目的历史提交记录 </li>
<li>复制提交SHA( commit 的 hash 值)</li>
<li>使用如下命令即可从当前 commit 拉分支。（8d8c42d3a83d8e1c96a1c3dfbf1c0d6411ad9f5a 是 commit  hash值，newBranch 是分支名称）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 第一种</div><div class="line">git checkout commitId -b newBranch </div><div class="line"># 第二种 </div><div class="line">git checkout -b newBranch 8d8c42d3a83d8e1c96a1c3dfbf1c0d6411ad9f5a</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、查看git提交记录&quot;&gt;&lt;a href=&quot;#1、查看git提交记录&quot; class=&quot;headerlink&quot; title=&quot;1、查看git提交记录&quot;&gt;&lt;/a&gt;1、查看git提交记录&lt;/h3&gt;&lt;h4 id=&quot;查看详细的提交记录&quot;&gt;&lt;a href=&quot;#查看详细的提交记录&quot; class=&quot;headerlink&quot; title=&quot;查看详细的提交记录&quot;&gt;&lt;/a&gt;查看详细的提交记录&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git log&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;查看简略的提交记录&quot;&gt;&lt;a href=&quot;#查看简略的提交记录&quot; class=&quot;headerlink&quot; title=&quot;查看简略的提交记录&quot;&gt;&lt;/a&gt;查看简略的提交记录&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git log --oneline&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="版本控制" scheme="https://guohenkai.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Git" scheme="https://guohenkai.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>配置SSH</title>
    <link href="https://guohenkai.github.io/2022/07/10/%E9%85%8D%E7%BD%AESSH/"/>
    <id>https://guohenkai.github.io/2022/07/10/配置SSH/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2022-10-17T10:58:04.253Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SSH作用"><a href="#SSH作用" class="headerlink" title="SSH作用"></a>SSH作用</h4><p>省去git pull push输入用户名密码的步骤， 保证传输安全</p>
<h4 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h4><ol>
<li><p>git bash上面执行生成SSH秘钥 ssh-keygen -t rsa -C “xxx@coolcollege.cn” 引号内为邮箱地址，一直回车 </p>
<a id="more"></a>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78g2d7ucij20mn0dowl6.jpg" alt="image"></p>
</li>
<li><p>查看C:\Users\Administrator.ssh文件夹下会生成两个文件 私钥  id_rsa.和公钥  id_rsa.pub </p>
</li>
<li><p>打开C:\Users\admin.ssh文件夹，复制id_rsa.pub里的内容，打开gitlab的找到User Settings下的SSH Keys添加<br><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78g2rq9l5j21gy0fw16y.jpg" alt="image"></p>
</li>
<li>完成后可直接使用ssh拉取项目代码 </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;SSH作用&quot;&gt;&lt;a href=&quot;#SSH作用&quot; class=&quot;headerlink&quot; title=&quot;SSH作用&quot;&gt;&lt;/a&gt;SSH作用&lt;/h4&gt;&lt;p&gt;省去git pull push输入用户名密码的步骤， 保证传输安全&lt;/p&gt;
&lt;h4 id=&quot;配置步骤&quot;&gt;&lt;a href=&quot;#配置步骤&quot; class=&quot;headerlink&quot; title=&quot;配置步骤&quot;&gt;&lt;/a&gt;配置步骤&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;git bash上面执行生成SSH秘钥 ssh-keygen -t rsa -C “xxx@coolcollege.cn” 引号内为邮箱地址，一直回车 &lt;/p&gt;
    
    </summary>
    
      <category term="GitLab" scheme="https://guohenkai.github.io/categories/GitLab/"/>
    
    
      <category term="GitLab" scheme="https://guohenkai.github.io/tags/GitLab/"/>
    
  </entry>
  
  <entry>
    <title>GitLab安装</title>
    <link href="https://guohenkai.github.io/2022/06/26/GitLab%E5%AE%89%E8%A3%85/"/>
    <id>https://guohenkai.github.io/2022/06/26/GitLab安装/</id>
    <published>2022-06-25T16:00:00.000Z</published>
    <updated>2022-10-17T10:56:17.541Z</updated>
    
    <content type="html"><![CDATA[<p>参看文档：<a href="https://docs.gitlab.com/omnibus/docker/README.html" target="_blank" rel="external">https://docs.gitlab.com/omnibus/docker/README.html</a></p>
<h3 id="更新GitLab"><a href="#更新GitLab" class="headerlink" title="更新GitLab"></a>更新GitLab</h3><h4 id="Stop-the-running-container"><a href="#Stop-the-running-container" class="headerlink" title="Stop the running container:"></a>Stop the running container:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker stop gitlab</div></pre></td></tr></table></figure>
 <a id="more"></a>
<h4 id="Remove-existing-container"><a href="#Remove-existing-container" class="headerlink" title="Remove existing container:"></a>Remove existing container:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker rm gitlab</div></pre></td></tr></table></figure>
<h4 id="Pull-the-new-image"><a href="#Pull-the-new-image" class="headerlink" title="Pull the new image:"></a>Pull the new image:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker pull gitlab/gitlab-ce:latest</div></pre></td></tr></table></figure>
<h4 id="Create-the-container-once-again-with-previously-specified-options"><a href="#Create-the-container-once-again-with-previously-specified-options" class="headerlink" title="Create the container once again with previously specified options:"></a>Create the container once again with previously specified options:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sudo docker run --detach \</div><div class="line">--hostname gitlab.example.com \</div><div class="line">--publish 443:443 --publish 80:80 --publish 2002:22 \</div><div class="line">--name gitlab \</div><div class="line">--restart always \</div><div class="line">--volume /srv/gitlab/config:/etc/gitlab \</div><div class="line">--volume /srv/gitlab/logs:/var/log/gitlab \</div><div class="line">--volume /srv/gitlab/data:/var/opt/gitlab \</div><div class="line">gitlab/gitlab-ce:latest</div></pre></td></tr></table></figure>
<h3 id="配置GitLab到不同的端口"><a href="#配置GitLab到不同的端口" class="headerlink" title="配置GitLab到不同的端口"></a>配置GitLab到不同的端口</h3><h4 id="Use-the-following-docker-run-command"><a href="#Use-the-following-docker-run-command" class="headerlink" title="Use the following docker run command:"></a>Use the following docker run command:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sudo docker run --detach \</div><div class="line">  --hostname gitlab.example.com \</div><div class="line">  --publish 8929:8929 --publish 2289:22 \</div><div class="line">  --name gitlab \</div><div class="line">  --restart always \</div><div class="line">  --volume /srv/gitlab/config:/etc/gitlab \</div><div class="line">  --volume /srv/gitlab/logs:/var/log/gitlab \</div><div class="line">  --volume /srv/gitlab/data:/var/opt/gitlab \</div><div class="line">  gitlab/gitlab-ce:latest</div></pre></td></tr></table></figure>
<h4 id="Enter-the-running-container"><a href="#Enter-the-running-container" class="headerlink" title="Enter the running container:"></a>Enter the running container:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker exec -it gitlab /bin/bash</div></pre></td></tr></table></figure>
<h4 id="Open-etc-gitlab-gitlab-rb-with-your-editor-and-set-external-url"><a href="#Open-etc-gitlab-gitlab-rb-with-your-editor-and-set-external-url" class="headerlink" title="Open /etc/gitlab/gitlab.rb with your editor and set external_url:"></a>Open /etc/gitlab/gitlab.rb with your editor and set external_url:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># For HTTP</div><div class="line">external_url &quot;http://gitlab.example.com:8929&quot;</div><div class="line">or</div><div class="line"># For HTTPS (notice the https)</div><div class="line">external_url &quot;https://gitlab.example.com:8929&quot;</div></pre></td></tr></table></figure>
<h4 id="Set-gitlab-shell-ssh-port"><a href="#Set-gitlab-shell-ssh-port" class="headerlink" title="Set gitlab_shell_ssh_port:"></a>Set gitlab_shell_ssh_port:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 2289</div></pre></td></tr></table></figure>
<h4 id="Finally-reconfigure-GitLab"><a href="#Finally-reconfigure-GitLab" class="headerlink" title="Finally, reconfigure GitLab:"></a>Finally, reconfigure GitLab:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab-ctl reconfigure</div></pre></td></tr></table></figure>
<h3 id="退出docker-container"><a href="#退出docker-container" class="headerlink" title="退出docker container"></a>退出docker container</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctr + d</div></pre></td></tr></table></figure>
<h3 id="gitlab-runner"><a href="#gitlab-runner" class="headerlink" title="gitlab runner"></a>gitlab runner</h3><p><a href="https://docs.gitlab.com/runner/register/" target="_blank" rel="external">https://docs.gitlab.com/runner/register/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参看文档：&lt;a href=&quot;https://docs.gitlab.com/omnibus/docker/README.html&quot;&gt;https://docs.gitlab.com/omnibus/docker/README.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新GitLab&quot;&gt;&lt;a href=&quot;#更新GitLab&quot; class=&quot;headerlink&quot; title=&quot;更新GitLab&quot;&gt;&lt;/a&gt;更新GitLab&lt;/h3&gt;&lt;h4 id=&quot;Stop-the-running-container&quot;&gt;&lt;a href=&quot;#Stop-the-running-container&quot; class=&quot;headerlink&quot; title=&quot;Stop the running container:&quot;&gt;&lt;/a&gt;Stop the running container:&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo docker stop gitlab&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="版本控制" scheme="https://guohenkai.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Git" scheme="https://guohenkai.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS分享</title>
    <link href="https://guohenkai.github.io/2022/05/15/NodeJs%E5%88%86%E4%BA%AB/"/>
    <id>https://guohenkai.github.io/2022/05/15/NodeJs分享/</id>
    <published>2022-05-14T16:00:00.000Z</published>
    <updated>2022-10-17T10:54:11.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nodejs简介"><a href="#nodejs简介" class="headerlink" title="nodejs简介"></a>nodejs简介</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><h5 id="非租塞式的异步I-O"><a href="#非租塞式的异步I-O" class="headerlink" title="非租塞式的异步I/O"></a>非租塞式的异步I/O</h5><p>绝大多数的API和操作都以异步回调的方式执行，每个调用之间无须等待之前的I/O调用结束。为了适应更多的应用场景，大多数异步API都有对应的同步API来处理流程的控制。</p>
<h5 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h5><p>以前端浏览器中应用成熟的事件机制为参考，node也实现了事件模块，配合异步IO来完成异步流程的调度和控制。这样我们就可以轻量级、松耦合的关注事务本身的业务逻辑。<br> <a id="more"></a></p>
<h5 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h5><p>Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>在高并发的网络应用场景和IO密集型的应用场景中，有着明显的优势</p>
<p>事件驱动、非阻塞式 I/O 的模型，异步编程。由于node更改了连接到服务器的方式，每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程，也不用为每一个链接分配内存。</p>
<p>不会线程死锁，因为根本就不允许使用锁。</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>单进程</p>
<p>异步回调的方式，处理流程累的业务比较费力</p>
<h3 id="二、Buffer"><a href="#二、Buffer" class="headerlink" title="二、Buffer"></a>二、Buffer</h3><h4 id="常用的字符编码"><a href="#常用的字符编码" class="headerlink" title="常用的字符编码"></a>常用的字符编码</h4><ul>
<li>utf8：多字节编码的 Unicode 字符</li>
<li>hex：将每个字节编码成两个十六进制的字符</li>
<li>base64：基于64个可打印字符来表示二进制数据的字符集</li>
<li>ascii: 美国信息交换标准代码,即用来表示英文字母和特殊控制字符的二进制数组</li>
<li>binary： Unicode 字符。 每个字符使用单个字节进行编码。超出该范围的字符会被截断，并映射成该范围内的字符</li>
</ul>
<h4 id="Buffer的数据类型"><a href="#Buffer的数据类型" class="headerlink" title="Buffer的数据类型"></a>Buffer的数据类型</h4><blockquote>
<p>端模式：在计算机中，我们是以字节为单位的，每个地址单元都对应着一个字节，16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着如果将多个字节安排的问题。就有了大端存储模式和小端存储模式</p>
</blockquote>
<ul>
<li>大端 - [BE]：高字节在前，低字节在后</li>
<li>小端 - [LE]：低字节在前，高字节在后</li>
</ul>
<h5 id="Int：整形"><a href="#Int：整形" class="headerlink" title="Int：整形"></a>Int：整形</h5><p>有符号：二进制最高位是符号位，1位正数，0位负数，其余位数标识数值本身。单字节取值-128~127</p>
<p>无符号：全部位数为数值本身，均为正数。单字节取值0~255</p>
<ul>
<li>Int8: 8位有符号</li>
<li>UInt8：8位无符号</li>
<li>Int16BE：大端16位有符号</li>
<li>UInt16BE：大端16位无符号</li>
<li>Int16LE：小端16位有符号</li>
<li>UInt16LE：小端16位无符号</li>
<li>Int32BE：大端32位有符号</li>
<li>UInt32BE：大端32位无符号</li>
<li>Int32LE：小端32位有符号</li>
<li>UInt32LE：小端32位无符号</li>
<li>BigInt64BE：大端64位有符号</li>
<li>BigUInt64BE：大端64位无符号</li>
<li>BigInt64LE：小端64位有符号</li>
<li>BigUInt64LE：掉段64位无符号</li>
</ul>
<h5 id="Float：单精度浮点（32位）"><a href="#Float：单精度浮点（32位）" class="headerlink" title="Float：单精度浮点（32位）"></a>Float：单精度浮点（32位）</h5><ul>
<li>FloatBE：大端单精度浮点</li>
<li>FloatLE：小端单精度浮点</li>
</ul>
<h5 id="Double：双精度浮点（64位）"><a href="#Double：双精度浮点（64位）" class="headerlink" title="Double：双精度浮点（64位）"></a>Double：双精度浮点（64位）</h5><ul>
<li>DoubleBE：大端双精度浮点</li>
<li>DoubleLE：小端双精度浮点</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//大端和小端的区别</div><div class="line">const buf = Buffer.alloc(2);</div><div class="line">buf.writeUInt16BE(300);// buf: &lt;Buffer 01 2c&gt;</div><div class="line">buf.writeUInt16LE(300);// buf: &lt;Buffer 2c 01&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//有符号和无符号的区别</div><div class="line">const buf = Buffer.alloc(1);</div><div class="line">buf.writeUInt8(128);//&lt;Buffer 80&gt;</div><div class="line">buf.writeInt8(128);//报错</div><div class="line">buf.writeUInt8(-1);//报错</div><div class="line">buf.writeUInt8(-1);//&lt;Buffer ff&gt;</div></pre></td></tr></table></figure>
<h4 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h4><h5 id="Buffer-alloc-size-fill-encoding"><a href="#Buffer-alloc-size-fill-encoding" class="headerlink" title="Buffer.alloc(size[, fill[, encoding]])"></a>Buffer.alloc(size[, fill[, encoding]])</h5><p>创建一个新的空buffer.</p>
<blockquote>
<p>buffer一旦创建，长度不能更改。如果给buffer中设置的内容长度超出buffer本身的长度，则会报ERR_INVALID_OPT_VALUE错误</p>
</blockquote>
<ul>
<li>size: {number} - 新buffer的长度</li>
<li>fill: {*} - 新buffer预填充的内容。如果不填充，用0默认</li>
<li>encoding: {string} - 声明fill内容的字符编码，默认utf8</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//&lt;Buffer 00 00 00 00 00&gt;</div><div class="line">const buf = Buffer.alloc(5);</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Buffer-from-data"><a href="#Buffer-from-data" class="headerlink" title="Buffer.from(data)"></a>Buffer.from(data)</h5><p>将某一段数据转为buffer</p>
<ul>
<li>data: {*} - 数据</li>
</ul>
<h5 id="Buffer-byteLength-string-encoding"><a href="#Buffer-byteLength-string-encoding" class="headerlink" title="Buffer.byteLength(string[, encoding])"></a>Buffer.byteLength(string[, encoding])</h5><p>计算一段数据的字节数</p>
<ul>
<li>string： {*} - 要进行计算长度的数据内容</li>
<li>encoding: {string} - 数据内容的字符编码，默认utf8</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const buf = Buffer.byteLength(&apos;你好&apos;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Buffer-compare-buf1-buf2"><a href="#Buffer-compare-buf1-buf2" class="headerlink" title="Buffer.compare(buf1, buf2)"></a>Buffer.compare(buf1, buf2)</h5><p>用于比较两段buffer的数值是否一致，相同则返回0，不同返回-1</p>
<h5 id="Buffer-concat-list-totalLength"><a href="#Buffer-concat-list-totalLength" class="headerlink" title="Buffer.concat(list[, totalLength])"></a>Buffer.concat(list[, totalLength])</h5><p>按照数组的顺序，合并两段buffer,返回一个新的buffer</p>
<ul>
<li>list: {array} - 要合并的buffer数组，</li>
<li>totalLength: {number} - 合并后buffer的总长度，默认为list数组长度总和</li>
</ul>
<h5 id="buf-copy-target-targetStart-sourceStart-sourceEnd"><a href="#buf-copy-target-targetStart-sourceStart-sourceEnd" class="headerlink" title="buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])"></a>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</h5><p>从目标buffer中拷贝指定长度的buffer到当前buffer中,并返回拷贝了多少个字节长度值</p>
<ul>
<li>taget: {buffer} - 要拷贝的目标对象</li>
<li>tagetStart: {number} - 拷贝对象的起始下表，即偏移量。默认0</li>
<li>sourceStart: {number} - buf中开始拷贝的起始偏移量，默认0</li>
<li>sourceEnd: {number} - buf中结束拷贝的偏移量，默认buf的length</li>
</ul>
<h5 id="buf-fill-value-offset-end-encoding"><a href="#buf-fill-value-offset-end-encoding" class="headerlink" title="buf.fill(value, offset, end, encoding)"></a>buf.fill(value, offset, end, encoding)</h5><ul>
<li>value: {*} - 用来填充的数据值</li>
<li>offset: {number}- 开始填充的偏移量，默认0</li>
<li>end: {number} - 结束填充的偏移量，默认buf的length</li>
<li>encoding: {string} - 填充内容的字符编码</li>
</ul>
<h5 id="buf-length"><a href="#buf-length" class="headerlink" title="buf.length"></a>buf.length</h5><p>返回一段buffer的字节长度</p>
<h5 id="buffer数据读写操作"><a href="#buffer数据读写操作" class="headerlink" title="buffer数据读写操作"></a>buffer数据读写操作</h5><p>以下API没有列举全部，只是通过部分API展示API的命名规则和使用方法，在buffer的数据类型中，每一个数据类型都有对应的读写API，具体参考官方文档的API。</p>
<ul>
<li>readInt8(offset)</li>
<li>writeInt8(offset)</li>
<li>readUInt8(offset)</li>
<li>writeUInt8(offset)</li>
<li>readInt16BE(offset)</li>
<li>writeInt16BE(value, offset)</li>
<li>readInt16LE(offset)</li>
<li>writeInt16LE(value, offset)</li>
<li>readUInt16LE(offset)</li>
<li>writeUInt16LE(value, offset)</li>
</ul>
<h3 id="三、练习"><a href="#三、练习" class="headerlink" title="三、练习"></a>三、练习</h3><h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h4><p>计算HEX色值 “#A265FE”的RGB色值</p>
<p>计算GRB色值 (231, 65, 132) 的HEX色值</p>
<h4 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h4><p>将以下两段字符串转换为一句完整的中文文本，不能有乱码</p>
<ul>
<li>‘ZTVhNTk0ZTZiNjhjZTU5MA==’</li>
<li>‘YTdlZmJjOGNlNTkwOGVlNmI1YWFlZmJjODE=’</li>
</ul>
<blockquote>
<p>提示：<br>本字符串可看出是base64编码，在破解webStorm，接入微信、钉钉等第三方开放接口，在鉴权验证出也都能遇到base64编码的应用。<br>转为buffer<br>转为utf8，拿到hex文本<br>HEX转buffer<br>将两段buffer合并<br>转为utf8，即看到一句中文描述</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;nodejs简介&quot;&gt;&lt;a href=&quot;#nodejs简介&quot; class=&quot;headerlink&quot; title=&quot;nodejs简介&quot;&gt;&lt;/a&gt;nodejs简介&lt;/h3&gt;&lt;h4 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h4&gt;&lt;h5 id=&quot;非租塞式的异步I-O&quot;&gt;&lt;a href=&quot;#非租塞式的异步I-O&quot; class=&quot;headerlink&quot; title=&quot;非租塞式的异步I/O&quot;&gt;&lt;/a&gt;非租塞式的异步I/O&lt;/h5&gt;&lt;p&gt;绝大多数的API和操作都以异步回调的方式执行，每个调用之间无须等待之前的I/O调用结束。为了适应更多的应用场景，大多数异步API都有对应的同步API来处理流程的控制。&lt;/p&gt;
&lt;h5 id=&quot;事件驱动&quot;&gt;&lt;a href=&quot;#事件驱动&quot; class=&quot;headerlink&quot; title=&quot;事件驱动&quot;&gt;&lt;/a&gt;事件驱动&lt;/h5&gt;&lt;p&gt;以前端浏览器中应用成熟的事件机制为参考，node也实现了事件模块，配合异步IO来完成异步流程的调度和控制。这样我们就可以轻量级、松耦合的关注事务本身的业务逻辑。&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="https://guohenkai.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="https://guohenkai.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>React-refs的使用</title>
    <link href="https://guohenkai.github.io/2022/04/03/React-refs%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://guohenkai.github.io/2022/04/03/React-refs的使用/</id>
    <published>2022-04-02T16:00:00.000Z</published>
    <updated>2022-10-17T09:23:42.048Z</updated>
    
    <content type="html"><![CDATA[<p>简书链接：<a href="https://www.jianshu.com/p/0075fe48a11e" target="_blank" rel="external">https://www.jianshu.com/p/0075fe48a11e</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简书链接：&lt;a href=&quot;https://www.jianshu.com/p/0075fe48a11e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.jianshu.com/p/0075fe48a11e&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="React" scheme="https://guohenkai.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://guohenkai.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Router4 BrowserRouter刷新导致的404问题</title>
    <link href="https://guohenkai.github.io/2022/03/13/React%20Router4%20BrowserRouter%E5%88%B7%E6%96%B0%E5%AF%BC%E8%87%B4%E7%9A%84404%E9%97%AE%E9%A2%98/"/>
    <id>https://guohenkai.github.io/2022/03/13/React Router4 BrowserRouter刷新导致的404问题/</id>
    <published>2022-03-12T16:00:00.000Z</published>
    <updated>2022-10-17T09:40:29.533Z</updated>
    
    <content type="html"><![CDATA[<p> 在学习React Router4 的BrowserRouter时，出现了一个棘手的问题，就是页面导航到其他路径后，刷新一下浏览器，就出现了页面404的问题，官网文档也没有相关的介绍，在百度谷歌之后，最终知道了出现这种问题的原因。</p>
<p> BrowserRouter是通过HTML5的history API来改变URL，并与服务器配合实现的路由切换的。当页面导航到非根路径如 /a/b 时，刷新浏览器，相当于去请求服务器的 /a/b 路径，而不是单页面app的入口文件index.html，所以出现的404的问题。解决办法如下：</p>
<p>1.在webpack-dev-server 命令中加上配置项 –history-api-fallback<br> <a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line"></div><div class="line">	&quot;start&quot;: &quot;webpack-dev-server --open --inline --content-base . --history-api-fallback --config ./build/webpack.dev.conf.js&quot;,</div><div class="line"></div><div class="line">	&quot;build&quot;: &quot;webpack --config ./build/webpack.prod.conf.js&quot;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.在webpack的配置文件中，设置devServer的historyApiFallback为true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">devServer:&#123;</div><div class="line">    contentBase:&apos;./&apos;,</div><div class="line">    host:&apos;localhost&apos;,</div><div class="line">    compress:true,</div><div class="line">    port:1717,</div><div class="line">    historyApiFallback: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>historyApiFallback设置为true，表示启用HTML5的history API后，所有的请求路径都会走入口文件index.html，这样配置的路由就会生效，不会出现404问题。</p>
<p>还要注意需要修改index.html入口文件引入打包后文件的路径，以避免多层级路由无法访问的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta charset=&quot;utf-8&quot;/&gt;</div><div class="line">        &lt;title&gt;react-webpack&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</div><div class="line">        &lt;div id=&apos;dialog-root&apos;&gt;&lt;/div&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;% for (var chunk in htmlWebpackPlugin.files.chunks) &#123; %&gt;</div><div class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;/&lt;%=htmlWebpackPlugin.files.chunks[chunk].entry %&gt;&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;% &#125; %&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在学习React Router4 的BrowserRouter时，出现了一个棘手的问题，就是页面导航到其他路径后，刷新一下浏览器，就出现了页面404的问题，官网文档也没有相关的介绍，在百度谷歌之后，最终知道了出现这种问题的原因。&lt;/p&gt;
&lt;p&gt; BrowserRouter是通过HTML5的history API来改变URL，并与服务器配合实现的路由切换的。当页面导航到非根路径如 /a/b 时，刷新浏览器，相当于去请求服务器的 /a/b 路径，而不是单页面app的入口文件index.html，所以出现的404的问题。解决办法如下：&lt;/p&gt;
&lt;p&gt;1.在webpack-dev-server 命令中加上配置项 –history-api-fallback&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://guohenkai.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://guohenkai.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Hooks常见问题总结</title>
    <link href="https://guohenkai.github.io/2022/02/20/Hooks%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://guohenkai.github.io/2022/02/20/Hooks常见问题总结/</id>
    <published>2022-02-19T16:00:00.000Z</published>
    <updated>2022-10-17T09:40:14.279Z</updated>
    
    <content type="html"><![CDATA[<p>对于api的解释和使用官网上有很详细的文档，建议先阅读官方文档。</p>
<p><strong>Hook Api</strong>: <a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="external">https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation</a></p>
<h4 id="1-函数组件的渲染过程"><a href="#1-函数组件的渲染过程" class="headerlink" title="1. 函数组件的渲染过程"></a>1. 函数组件的渲染过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">  	console.log(&apos;render&apos;)</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line">		console.log(count);</div><div class="line">    return &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;count: &#123;count&#125;&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <a id="more"></a>
<p>每次点击p标签，count都会 + 1，setCount会触发函数组件的渲染。函数组件的重新渲染其实是当前函数的重新执行。 在函数组件的每一次渲染中，内部的state、函数以及传入的props都是独立的。</p>
<h4 id="2-useStates和useReducer"><a href="#2-useStates和useReducer" class="headerlink" title="2. useStates和useReducer"></a>2. useStates和useReducer</h4><h5 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h5><ul>
<li>useState设置初始值时，如果初始值是个值，可以直接设置，如果是个函数返回值，建议使用回调函数的方式设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const initCount = c =&gt; &#123;</div><div class="line">    console.log(&apos;initCount 执行&apos;);</div><div class="line">    return c * 2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(initCount(0));</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样会发现，重新渲染时并不会给count重新赋初始值，但是initCount每次都执行了<br>修改成回调函数方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const initCount = c =&gt; &#123;</div><div class="line">    console.log(&apos;initCount 执行&apos;);</div><div class="line">    return c * 2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(() =&gt; initCount(0));</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候，initCount函数只会在Counter组件初始化的时候执行，之后无论组件如何渲染，initCount函数都不会再执行</p>
<ul>
<li>useReducer设置初始值时，初始值只能是个值，不能使用回调函数的方式<ul>
<li>如果是个执行函数返回值，那么在组件重新渲染时，这个执行函数依然会执行</li>
</ul>
</li>
</ul>
<h5 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h5><ul>
<li>useState修改状态时，同一个useState声明的状态会被覆盖处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line"></div><div class="line">    return (</div><div class="line">        &lt;p</div><div class="line">            onClick=&#123;() =&gt; &#123;</div><div class="line">                setCount(count + 1);</div><div class="line">                setCount(count + 2);</div><div class="line">            &#125;&#125;</div><div class="line">        &gt;</div><div class="line">            clicked &#123;count&#125; times</div><div class="line">        &lt;/p&gt;</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当前界面中count的step是 2，每次点击的时候，只会执行+2的操作</p>
<ul>
<li>useReducer修改状态时，多次dispatch会按顺序执行，依次对组件进行渲染<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, dispatch] = useReducer((x, payload) =&gt; x + payload, 0);</div><div class="line"></div><div class="line">    return (</div><div class="line">        &lt;p</div><div class="line">            onClick=&#123;() =&gt; &#123;</div><div class="line">                dispatch(1);</div><div class="line">                dispatch(2);</div><div class="line">            &#125;&#125;</div><div class="line">        &gt;</div><div class="line">            clicked &#123;count&#125; times</div><div class="line">        &lt;/p&gt;</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当前界面中count的step是 3，每次点击的时候，会执行+3的操作</p>
<h4 id="3-useEffect"><a href="#3-useEffect" class="headerlink" title="3. useEffect"></a>3. useEffect</h4><p>该 Hook 接收一个包含命令式、且可能有副作用代码的函数。默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候 才执行。</p>
<p><strong>使用useEffect模拟componentDidMount</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line"></div><div class="line">    useEffect(() =&gt; &#123;</div><div class="line">        console.log(&apos;count: &apos;, count);</div><div class="line">        // 设置依赖为一个空数组</div><div class="line">    &#125;, []);</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将依赖设置为空数组，可以看到，只有在组件初次渲染时才会在控制台打印输出。之后无论count怎么变化，都不会再次打印。</p>
<p><strong>使用useEffect模拟componentDidMount</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line"></div><div class="line">    useEffect(() =&gt; &#123;</div><div class="line">         const handleClick = function() &#123;</div><div class="line">       		console.log(&apos;click&apos;)</div><div class="line">        &#125;</div><div class="line">        window.addEventListener(&apos;click&apos;, handleClick, false)</div><div class="line"></div><div class="line">        return () =&gt; &#123;</div><div class="line">          window.removeEventListener(&apos;click&apos;, handleClick, false)</div><div class="line">        &#125;;</div><div class="line">    &#125;, []);</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>useEffect函数需返回一个清除函数，为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。</p>
<blockquote>
<p>给 useEffect 设置 依赖项为空数组，并且 返回一个函数，那么这个返回的函数就相当于是 componentWillUnmount<br>请注意，必须要设置依赖项为空数组。如果不是空数组，那么这个函数并不是在组件被卸载时触发，而是会在组件重新渲染，清理上一帧的数据时触发。</p>
</blockquote>
<h5 id="在useEffect、useCallback、useMemo中获取到的state、props为什么是旧值"><a href="#在useEffect、useCallback、useMemo中获取到的state、props为什么是旧值" class="headerlink" title="在useEffect、useCallback、useMemo中获取到的state、props为什么是旧值"></a>在useEffect、useCallback、useMemo中获取到的state、props为什么是旧值</h5><p>函数组件的每一帧都有自己独立的state、function、props。而这三个函数都有缓存功能。所以在我们没有设置正确的依赖项的时候，那么useEffect、useCallback、useMemo就不会重新执行，其中使用的变量还是之前的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line"></div><div class="line">    useEffect(() =&gt; &#123;</div><div class="line">         const handleClick = function() &#123;</div><div class="line">       		console.log(count)</div><div class="line">        &#125;</div><div class="line">        window.addEventListener(&apos;click&apos;, handleClick, false)</div><div class="line"></div><div class="line">        return () =&gt; &#123;</div><div class="line">          window.removeEventListener(&apos;click&apos;, handleClick, false)</div><div class="line">        &#125;;</div><div class="line">    &#125;, []);</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>像这里依赖项设置为空数组，无论count怎么改拜年，打印出来的都是0.</p>
<h5 id="useEffect中为什么会出现无限执行的情况"><a href="#useEffect中为什么会出现无限执行的情况" class="headerlink" title="useEffect中为什么会出现无限执行的情况"></a>useEffect中为什么会出现无限执行的情况</h5><p>● 没有为useEffect设置依赖项，并且在useEffect中更新state，或者在useEffect中更新了依赖项会导致界面无限重复渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line"></div><div class="line">  	// 1</div><div class="line">    useEffect(() =&gt; &#123;</div><div class="line">      setCount(count + 1);</div><div class="line">    &#125;);</div><div class="line">   // 2</div><div class="line">  	useEffect(() =&gt; &#123;</div><div class="line">      setCount(count + 1);</div><div class="line">    &#125;, [count]);</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述两种情况都会导致页面无限刷新。</p>
<h4 id="4-useRef"><a href="#4-useRef" class="headerlink" title="4. useRef"></a>4. useRef</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const refContainer = useRef(initialValue);</div></pre></td></tr></table></figure>
<p>useRef返回一个可变的 ref 对象，其.current属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p>
<p>函数组建是没有this指向的，所以为了可以保存组件实例的属性，可以用useRef来进行操作。函数组件的ref具有可以穿透闭包的能力。通过将普通类型的值转换为一个带有current属性的对象引用，来保证每次访问到的属性值是最新的。</p>
<p>一个常见的用例便是命令式地访问子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function TextInputWithFocusButton() &#123;</div><div class="line">  const inputEl = useRef(null);</div><div class="line">  const onButtonClick = () =&gt; &#123;</div><div class="line">    // `current` 指向已挂载到 DOM 上的文本输入元素</div><div class="line">    inputEl.current.focus();</div><div class="line">  &#125;;</div><div class="line">  return (</div><div class="line">    &lt;&gt;</div><div class="line">      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt;</div><div class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;</div><div class="line">    &lt;/&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然而，useRef()比ref属性更有用。它可以很方便的保存任何可变值，其类似于在 class 中使用实例字段的方式。<br>这是因为它创建的是一个普通 Javascript 对象。而useRef()和自建一个{current: …}对象的唯一区别是，useRef会在每次渲染时返回同一个 ref 对象。</p>
<blockquote>
<p>请记住，当 ref 对象内容发生变化时，useRef并不会通知你。变更.current属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref来实现</p>
</blockquote>
<h4 id="5-useCallback"><a href="#5-useCallback" class="headerlink" title="5. useCallback"></a>5. useCallback</h4><p>当依赖频繁变更时，如何避免useCallback频繁执行呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line"></div><div class="line">    const handleClick = useCallback(() =&gt; &#123;</div><div class="line">        setCount(count + 1);</div><div class="line">    &#125;, [count]);</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;handleClick&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里，我们把click事件提取出来，使用useCallback包裹，但其实并没有起到很好的效果。</p>
<p>因为Counter组件重新渲染目前只依赖count的变化，所以这里的useCallback用与不用没什么区别。</p>
<h5 id="使用useReducer替代useState"><a href="#使用useReducer替代useState" class="headerlink" title="使用useReducer替代useState"></a>使用useReducer替代useState</h5><p>可以使用useReducer进行替代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, dispatch] = useReducer(x =&gt; x + 1, 0);</div><div class="line"></div><div class="line">    const handleClick = useCallback(() =&gt; &#123;</div><div class="line">        dispatch();</div><div class="line">    &#125;, []);</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;handleClick&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>useReducer返回的dispatch函数是自带了memoize的，不会在多次渲染时改变。因此在useCallback中不需要将dispatch作为依赖项。</p>
<h5 id="向setState中传递函数"><a href="#向setState中传递函数" class="headerlink" title="向setState中传递函数"></a>向setState中传递函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line"></div><div class="line">    const handleClick = useCallback(() =&gt; &#123;</div><div class="line">        setCount(c =&gt; c + 1);</div><div class="line">    &#125;, []);</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;handleClick&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在setCount中使用函数作为参数时，接收到的值是最新的state值，因此可以通过这个值执行操作</p>
<h5 id="使用useRef"><a href="#使用useRef" class="headerlink" title="使用useRef"></a>使用useRef</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Counter() &#123;</div><div class="line">    const [count, setCount] = useState(0);</div><div class="line">    const countRef = useRef(count);</div><div class="line"></div><div class="line">    useEffect(() =&gt; &#123;</div><div class="line">        countRef.current = count;</div><div class="line">    &#125;, [count]);</div><div class="line"></div><div class="line">    const handleClick = useCallback(() =&gt; &#123;</div><div class="line">        setCount(countRef.current + 1);</div><div class="line">    &#125;, []);</div><div class="line"></div><div class="line">    return &lt;p onClick=&#123;handleClick&#125;&gt;clicked &#123;count&#125; times&lt;/p&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-useMemo"><a href="#6-useMemo" class="headerlink" title="6. useMemo"></a>6. useMemo</h4><p>useMemo和useCallback的区别</p>
<ul>
<li>useMemo的返回值是一个值，可以是属性，可以是函数（包括组件）</li>
<li>useCallback的返回值只能是函数</li>
</ul>
<p>useCallback(fn, deps)相当于useMemo(() =&gt; fn, deps)</p>
<h4 id="7-useCallback-和-useMemo-是否应该频繁使用"><a href="#7-useCallback-和-useMemo-是否应该频繁使用" class="headerlink" title="7. useCallback 和 useMemo 是否应该频繁使用"></a>7. useCallback 和 useMemo 是否应该频繁使用</h4><p>答案是否定的。</p>
<ol>
<li>useMemo和useCallback不能盲目使用，因为他们都是基于闭包实现的，闭包会占用内存。</li>
<li>当依赖项频繁改动时，要考虑useMemo、useCallback是否划算，因为useCallback会频繁创建函数体。useMemo会频繁创建回调。<ul>
<li>useMemo和useCallback可以用来解决性能问题</li>
<li>useCallback需要与memo配合使用</li>
<li>useMemo与memo是完全不同的</li>
<li>useMemo和useCallback的源码几乎是一样的，useCallback返回的是回调函数，useMemo返回的是值</li>
<li>useMemo一般用于计算量比较大的情况</li>
<li>useMemo和useCallback不一定能达到性能优化的目的，因此不能盲目使用</li>
</ul>
</li>
</ol>
<h4 id="8-如何在父组件中调用子组件的方法"><a href="#8-如何在父组件中调用子组件的方法" class="headerlink" title="8.如何在父组件中调用子组件的方法"></a>8.如何在父组件中调用子组件的方法</h4><p>在函数组件中，没有组件实例，所以无法像类组件中，通过绑定子组件的实例调用子组件中的状态或者方法。</p>
<p>那么在函数组件中，如何在父组件调用子组件的状态或者方法呢？答案就是使用useImperativeHandle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useImperativeHandle(ref, createHandle, [deps])</div></pre></td></tr></table></figure></p>
<p>● 第一个参数是 ref 值，可以通过属性传入，也可以配合 forwardRef 使用<br>● 第二个参数是一个函数，返回一个对象，对象中的属性都会被挂载到第一个参数 ref 的 current 属性上<br>● 第三个参数是依赖的元素集合，同 useEffect、useCallback、useMemo，当依赖发生变化时，第二个参数会重新执行，重新挂载到第一个参数的 current 属性上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function FancyInput(props, ref) &#123;</div><div class="line">  const inputRef = useRef();</div><div class="line">  useImperativeHandle(ref, () =&gt; (&#123;</div><div class="line">    focus: () =&gt; &#123;</div><div class="line">      inputRef.current.focus();</div><div class="line">    &#125;</div><div class="line">  &#125;));</div><div class="line">  return &lt;input ref=&#123;inputRef&#125; ... /&gt;;</div><div class="line">&#125;</div><div class="line">FancyInput = forwardRef(FancyInput);</div></pre></td></tr></table></figure>
<p>在本例中，渲染<fancyinput ref="{inputRef}">的父组件可以调用inputRef.current.focus()</fancyinput></p>
<h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><p>● <a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="external">useEffect完整指南</a><br>● <a href="https://www.youtube.com/watch?v=TNhaISOUy6Q" target="_blank" rel="external">10 React Hooks Explained</a><br>● <a href="https://ahooks.js.org/" target="_blank" rel="external">a hooks library</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于api的解释和使用官网上有很详细的文档，建议先阅读官方文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hook Api&lt;/strong&gt;: &lt;a href=&quot;https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation&quot;&gt;https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-函数组件的渲染过程&quot;&gt;&lt;a href=&quot;#1-函数组件的渲染过程&quot; class=&quot;headerlink&quot; title=&quot;1. 函数组件的渲染过程&quot;&gt;&lt;/a&gt;1. 函数组件的渲染过程&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Counter() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  	console.log(&amp;apos;render&amp;apos;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    const [count, setCount] = useState(0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		console.log(count);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return &amp;lt;p onClick=&amp;#123;() =&amp;gt; setCount(count + 1)&amp;#125;&amp;gt;count: &amp;#123;count&amp;#125;&amp;lt;/p&amp;gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://guohenkai.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://guohenkai.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React的props和state</title>
    <link href="https://guohenkai.github.io/2021/12/12/React%E7%9A%84props%E5%92%8Cstate/"/>
    <id>https://guohenkai.github.io/2021/12/12/React的props和state/</id>
    <published>2021-12-11T16:00:00.000Z</published>
    <updated>2022-10-17T09:40:05.694Z</updated>
    
    <content type="html"><![CDATA[<p>在任何应用中管理数据都是必不可少的。通过用户界面来编排数据流是一项具有挑战的工程。现代的 Web 应用会涉及复杂的 UI 交互，比如改变了一个地方的 UI 数据，需要直接或者间接的改变其他地方的 UI 数据。一些双向绑定的框架（比如：Angular.js 等）都是对这种场景比较好的解决方案。</p>
<p>对于一些应用（尤其是数据流比较简单的），这种双向绑定是非常快速和足够的解决方案。但是对于一些更加复杂的应用场景，数据双向绑定已经被证明是不够的，它会妨碍用户界面的设计。实际上，React 并没有解决这样一个复杂应用中比较复杂的数据流问题（虽然后面出现了 Flux 这种解决方案），但是他确实解决了一个组件中数据流的问题。</p>
<p>对于一个有上下文关系的组件， React 解决了数据流问题 —— 即通过更新 UI 来反应数据流的结果；除此之外，React 解决的另外一个问题是命名模式问题 —— 通过比较有创意的虚拟 DOM 解决。<br> <a id="more"></a></p>
<h4 id="一、-组件数据的类型：-组件数据存储在props和state中"><a href="#一、-组件数据的类型：-组件数据存储在props和state中" class="headerlink" title="一、 组件数据的类型： 组件数据存储在props和state中"></a>一、 组件数据的类型： 组件数据存储在props和state中</h4><p>props 是一个组件的输入。他经常被用作渲染组件和初始化状态。当实例化完一个组件，props 应该是不可变的（持久的）。props 被用作在实例化组件的时候，然后组件将再次渲染 DOM，在这个过程中，React 将会对比新 props 和老 props 然后来确定哪些 DOM 的变化是必要的。</p>
<blockquote>
<p>下面是一个设置 props 然后用 props 的变化来更新 DOM 的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">var HelloWorld = React.createClass(&#123;</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;span&gt;Counter: &#123;this.props.count&#125;&lt;/span&gt;</div><div class="line">        &lt;br /&gt;</div><div class="line">        &lt;input type=&quot;text&quot; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">&#125;);</div><div class="line">var mainElement = document.querySelector(&quot;main&quot;)</div><div class="line">count = 1</div><div class="line">setInterval(function() &#123;</div><div class="line">ReactDOM.render(&lt;HelloWorld count=&#123;count++&#125;&gt;&lt;/HelloWorld&gt;, mainElement)</div></pre></td></tr></table></figure>
<p>state 可以通过组组件发生变化，这种变化经常会和组件的事件处理函数连接起来。通常情况下，state的这种变化会触发组件的重新渲染。在组件初始化之前，他的 state 必须先进行初始化，其值包含常数、props。</p>
<h4 id="二、-props"><a href="#二、-props" class="headerlink" title="二、 props"></a>二、 props</h4><p>当我们给一个组件添加 css 样式的 class 时，我们必须用 className，而不是 class。这是因为在 ES 2015 中 class 是一个用来定义对象的保留字。为了去避免这种冲突，在 React 中使用了 className。如果你使用了 class，React 将会在 console 里面输出一段友好的提示，让你使用 className 而不是 class。 </p>
<p>除了像 className 一样这些 props 的名字之外，props 还有一些其他有意思的地方。比如改变 props 的值就是一种反模式。props 应该在组件实例化之前就进行设置，在这之后进行设置是不可的。其中就包括在组件实例化之后（render 之后）。可变值在组件中被认为是状态，一般使用 state 而不是 props。</p>
<p>在下面的这个例子中，someComponent 实例化了，在这之后 props 的值发生了变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var someComponent = &lt;SomeComponent /&gt;</div><div class="line">someComponent.props.prop1 = “some value”</div><div class="line">someComponent.props.prop2 = “some value”</div></pre></td></tr></table></figure></p>
<p>改变 props 的值会让应用程序发生一些错误，并且这种错误是无法跟踪的。于此同时，改变 props 的值不会触发组件的再次渲染，这样就会让数据和界面不是同步的。<br>所以。props 应该在实例化的时候作为组件的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var someComponent = &lt;SomeComponent prop1=”some value” prop2=”some value” /&gt;</div></pre></td></tr></table></figure></p>
<p>这样，props 发生变化的时候就会协调进行 DOM 树的对比，然后进行 UI 的更新。</p>
<h4 id="三、-state"><a href="#三、-state" class="headerlink" title="三、 state"></a>三、 state</h4><p>state 表示组件内可变的状态，这个状态一般是由用户去作用而产生的。为了促成这种改变，事件处理程序将会作用在相应的 DOM 元素上，当事件触发之后，值将会从 DOM 上取得，然后去通知组件有一个新的 state。在组件使用 state 之前，state 必须通过 getInitialState 函数进行初始化。通常情况下，getInitilaState 函数通过静态值、props 或者其他数据源进行初始化 state。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var Message = React.createClass(&#123; </div><div class="line"></div><div class="line">getInitialState: function() &#123; </div><div class="line">   return &#123; message: this.props.message &#125;; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一旦 state 被初始化，就能像 props 一样在组件中使用了。为了去捕获用户的行为带来，然后去更新 state，各种需要使用的事件函数都会注册。为了保持组件的独立（和其他组件之间只通过数据进行交换，较少耦合性），每个事件处理函数都可以以 props的形式进性传递，也可以直接在组件内进行定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&quot;use strict&quot;</div><div class="line"></div><div class="line">var Message = React.createClass(&#123;</div><div class="line"></div><div class="line">  getInitialState: function() &#123;</div><div class="line">    return &#123; message: this.props.message &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  _messageChange: function(e) &#123;</div><div class="line">    this.setState(&#123; message: e.target.value &#125;)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;span&gt;Message: &#123;this.state.message&#125;&lt;/span&gt;</div><div class="line">        &lt;br /&gt;</div><div class="line">        Message: &lt;input type=&quot;text&quot; value=&#123;this.state.message&#125; onChange=&#123;this._messageChange&#125; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line">var mainElement = document.querySelector(&quot;main&quot;)</div><div class="line"></div><div class="line">ReactDOM.render(&lt;Message message=&quot;Hello World!!&quot; /&gt;, mainElement)</div></pre></td></tr></table></figure>
<p>React 的另外一个优点就是使用了标准的 HTML 事件。这样一来学习特殊的事件库，事件处理函数和第三方事件就不再是需要的。</p>
<p>为了去处理 state 的变化，setState 函数被用来设置 state 的新值。调用这个函数会触发组件的重新渲染。</p>
<h4 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h4><p>React 组件对数据提供了两种机制： props 与 state。他把数据清楚的划分为了持久性数据 props 与经常改变的数据 state，然后把这两种数据和组件产生关联。</p>
<p>通常意义上，对于简单的数据流 props 是首选的，state 对于捕获用户交互或者其他 UI 事件造成的数据更新是非常有用的。</p>
<p>props 和 state 之间的关系促成了数据通过组件的流动。props 可以用来初始化 state，state 可以在初始化、渲染组件的使用设置 props。通过 state 来捕获用户输出的值、更新 props</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在任何应用中管理数据都是必不可少的。通过用户界面来编排数据流是一项具有挑战的工程。现代的 Web 应用会涉及复杂的 UI 交互，比如改变了一个地方的 UI 数据，需要直接或者间接的改变其他地方的 UI 数据。一些双向绑定的框架（比如：Angular.js 等）都是对这种场景比较好的解决方案。&lt;/p&gt;
&lt;p&gt;对于一些应用（尤其是数据流比较简单的），这种双向绑定是非常快速和足够的解决方案。但是对于一些更加复杂的应用场景，数据双向绑定已经被证明是不够的，它会妨碍用户界面的设计。实际上，React 并没有解决这样一个复杂应用中比较复杂的数据流问题（虽然后面出现了 Flux 这种解决方案），但是他确实解决了一个组件中数据流的问题。&lt;/p&gt;
&lt;p&gt;对于一个有上下文关系的组件， React 解决了数据流问题 —— 即通过更新 UI 来反应数据流的结果；除此之外，React 解决的另外一个问题是命名模式问题 —— 通过比较有创意的虚拟 DOM 解决。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://guohenkai.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://guohenkai.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React---创建同时受控组件与非受控的组件</title>
    <link href="https://guohenkai.github.io/2021/10/25/React---%E5%88%9B%E5%BB%BA%E5%90%8C%E6%97%B6%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%9A%84%E7%BB%84%E4%BB%B6/"/>
    <id>https://guohenkai.github.io/2021/10/25/React---创建同时受控组件与非受控的组件/</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2022-10-17T09:17:06.330Z</updated>
    
    <content type="html"><![CDATA[<p>简书地址：<a href="https://www.jianshu.com/p/4eee55e3dee2" target="_blank" rel="external">https://www.jianshu.com/p/4eee55e3dee2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简书地址：&lt;a href=&quot;https://www.jianshu.com/p/4eee55e3dee2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.jianshu.com/p/4eee55e3dee2&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="React" scheme="https://guohenkai.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://guohenkai.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React事件绑定this并传参</title>
    <link href="https://guohenkai.github.io/2021/10/24/React%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E4%BC%A0%E5%8F%82/"/>
    <id>https://guohenkai.github.io/2021/10/24/React事件绑定this并传参/</id>
    <published>2021-10-23T16:00:00.000Z</published>
    <updated>2022-10-17T10:51:37.018Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在事件中绑定this并传参："><a href="#在事件中绑定this并传参：" class="headerlink" title="在事件中绑定this并传参："></a>在事件中绑定this并传参：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; onClick=&#123;this.handleMsg1.bind(this, &apos;aa&apos;, &apos;bb&apos;)&#125; /&gt;</div><div class="line">// 在事件中绑定this并传参</div><div class="line">handleMsg1(arg1, arg2) &#123;</div><div class="line">    this.setState(&#123;</div><div class="line">        msg: &apos;在事件中绑定this并传参：&apos; + arg1 + arg2</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
 <a id="more"></a>
<h4 id="在构造函数中绑定this并传参"><a href="#在构造函数中绑定this并传参" class="headerlink" title="在构造函数中绑定this并传参:"></a>在构造函数中绑定this并传参:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">constructor(props) &#123;</div><div class="line">   super(props);</div><div class="line">   this.handleMsg2 = this.handleMsg2.bind(this);</div><div class="line"> &#125;</div><div class="line">  &lt;input type=&quot;button&quot; onClick=&#123;this.handleMsg2&#125; /&gt;</div><div class="line">  // 在构造函数中绑定this并传参</div><div class="line">  handleMsg2(arg1, arg2) &#123;</div><div class="line">      this.setState(&#123;</div><div class="line">          msg: &apos;在构造函数中绑定this并传参：&apos; + arg1 + arg2</div><div class="line">      &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="用箭头函数绑定this并传参："><a href="#用箭头函数绑定this并传参：" class="headerlink" title="用箭头函数绑定this并传参："></a>用箭头函数绑定this并传参：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; onClick=&#123;() =&gt; &#123; this.handleMsg3(&apos;cc&apos;, &apos;dd&apos;) &#125;&#125; /&gt;</div><div class="line">// 用箭头函数绑定this并传参</div><div class="line">    handleMsg3(arg1, arg2) &#123;</div><div class="line">        this.setState(&#123;</div><div class="line">            msg: &apos;用箭头函数绑定this并传参：&apos; + arg1 + arg2</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="使用箭头函数"><a href="#使用箭头函数" class="headerlink" title="使用箭头函数"></a>使用箭头函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; onClick=&#123;this.handleMsg4(&apos;cc&apos;, &apos;dd&apos;)&#125; /&gt;</div><div class="line">   // 用箭头函数绑定this并传参</div><div class="line">       handleMsg4 = (arg1, arg2) =&gt; &#123;</div><div class="line">           this.setState(&#123;</div><div class="line">               msg: &apos;用箭头函数绑定this并传参：&apos; + arg1 + arg2</div><div class="line">           &#125;);</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在事件中绑定this并传参：&quot;&gt;&lt;a href=&quot;#在事件中绑定this并传参：&quot; class=&quot;headerlink&quot; title=&quot;在事件中绑定this并传参：&quot;&gt;&lt;/a&gt;在事件中绑定this并传参：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;input type=&amp;quot;button&amp;quot; onClick=&amp;#123;this.handleMsg1.bind(this, &amp;apos;aa&amp;apos;, &amp;apos;bb&amp;apos;)&amp;#125; /&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 在事件中绑定this并传参&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;handleMsg1(arg1, arg2) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.setState(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        msg: &amp;apos;在事件中绑定this并传参：&amp;apos; + arg1 + arg2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://guohenkai.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://guohenkai.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>程序设计模式简介</title>
    <link href="https://guohenkai.github.io/2021/09/19/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <id>https://guohenkai.github.io/2021/09/19/程序设计模式简介/</id>
    <published>2021-09-18T16:00:00.000Z</published>
    <updated>2022-10-17T09:13:51.130Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的，是经过反复使用被多数人知晓并且经过分类编目和代码设计的总结。通常代表解决某一类型问题的最佳实践。</p>
<h4 id="使用设计模式的目的"><a href="#使用设计模式的目的" class="headerlink" title="使用设计模式的目的"></a>使用设计模式的目的</h4><ul>
<li>重用代码</li>
<li>让代码易读、可维护</li>
<li>保证代码的可靠性</li>
<li>代码编制工程化<a id="more"></a>
<h4 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h4></li>
</ul>
<ol>
<li>创建类型（5）：创建对象的同时，隐藏创建逻辑。使程序在判断某个实例需要创建哪些对象时更灵活</li>
<li>结构类型（8）：关注类和对象的组合。以继承的方式组合接口和定义组合对象来获得新功能</li>
<li>行为类型（12）：关注对象之间的通信</li>
<li>J2EE（8）：比较关注表示层，通常用来处理业务逻辑</li>
</ol>
<h4 id="6大原则"><a href="#6大原则" class="headerlink" title="6大原则"></a>6大原则</h4><ol>
<li>开闭原则</li>
<li>里氏代换原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ol>
<h4 id="常见的设计模式列表"><a href="#常见的设计模式列表" class="headerlink" title="常见的设计模式列表"></a>常见的设计模式列表</h4><ul>
<li>工厂模式</li>
<li>单例模式</li>
<li>原型模式</li>
<li>建造者模式</li>
<li>适配器模式</li>
<li>桥接模式</li>
<li>过滤器模式</li>
<li>组合模式</li>
<li>装饰器模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>观察者模式</li>
<li>状态模式</li>
<li>空对象模式</li>
<li>策略模式</li>
<li>模板模式</li>
<li>访问者模式</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h4&gt;&lt;p&gt;设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的，是经过反复使用被多数人知晓并且经过分类编目和代码设计的总结。通常代表解决某一类型问题的最佳实践。&lt;/p&gt;
&lt;h4 id=&quot;使用设计模式的目的&quot;&gt;&lt;a href=&quot;#使用设计模式的目的&quot; class=&quot;headerlink&quot; title=&quot;使用设计模式的目的&quot;&gt;&lt;/a&gt;使用设计模式的目的&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;重用代码&lt;/li&gt;
&lt;li&gt;让代码易读、可维护&lt;/li&gt;
&lt;li&gt;保证代码的可靠性&lt;/li&gt;
&lt;li&gt;代码编制工程化
    
    </summary>
    
      <category term="JavaScript" scheme="https://guohenkai.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://guohenkai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://guohenkai.github.io/2021/08/15/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://guohenkai.github.io/2021/08/15/工厂模式/</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2022-10-31T15:00:56.315Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>工厂模式提供了议重创建对象的最佳实践方式，在工厂模式中，我们创建对象时，不会暴露创建逻辑，并且用一个共同的接口来指向新创建的对象</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类。把创建过程延迟到子类进行<br> <a id="more"></a></p>
<h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>解决接口选择的问题</p>
<h4 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h4><p>让子类实现工厂接口，返回也是一个抽象的产品</p>
<h4 id="代码特性"><a href="#代码特性" class="headerlink" title="代码特性"></a>代码特性</h4><p>创建过程在子类中执行</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>一个调用者需要创建一个对象，只需要知道接口名称就可以了</li>
<li>扩展性高，如果想增加一个产品，只需要扩展一个工厂类就可以了</li>
<li>屏蔽产品的具体实现，调用者只关心产品接口</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>每增加一个产品时，都需要增加一个具体类型和对象实现工厂，使系统中类的个数成倍数增加，在一定程度上增加了系统复杂度，也增加了系统类和类之间的相互依赖</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>日志记录</li>
<li>连接服务器</li>
<li>数据库访问<blockquote>
<p>在生成复杂对象的地方都可以使用工厂模式，而简单的对象，特别是能够new就完成的创建，无需使用工厂模式</p>
</blockquote>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">const user = new User();</div><div class="line">const user.Factory = function (model) &#123;</div><div class="line">  // TODO 校验model参数的合法性</div><div class="line">  </div><div class="line">  //返回子类实例化对象</div><div class="line">	return new user[model]();</div><div class="line">&#125;</div><div class="line">const Account = user.Factory(&apos;Account&apos;);</div><div class="line">const userAccount = Account.create(&#123;userName: &apos;244821681&apos;, password: &apos;asdsad&apos;, email: &apos;sjdkhs@qq.com&apos;&#125;);</div><div class="line"></div><div class="line"></div><div class="line">function User () &#123;</div><div class="line">  //子类1</div><div class="line">  function Account () &#123;</div><div class="line">  	this.create = function (content) &#123;</div><div class="line">      const &#123;userName, password, email&#125; = content;</div><div class="line">      </div><div class="line">      //参数校验</div><div class="line">      if (verify(&apos;string&apos;, userName)) &#123;</div><div class="line">      	return &apos;user name error&apos;;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      //构造对象</div><div class="line">    	const accountInfo = &#123;</div><div class="line">      	userName,</div><div class="line">        password,</div><div class="line">        email,</div><div class="line">        uid: new Date.getTime() + Math.ceil(Math.random() * 100)</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      //返回对象</div><div class="line">      return accountInfo;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  //子类2</div><div class="line">  function Profile () &#123;</div><div class="line">    this.add = function (content) &#123;</div><div class="line">      // TODO ...</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;工厂模式提供了议重创建对象的最佳实践方式，在工厂模式中，我们创建对象时，不会暴露创建逻辑，并且用一个共同的接口来指向新创建的对象&lt;/p&gt;
&lt;h4 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h4&gt;&lt;p&gt;定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类。把创建过程延迟到子类进行&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://guohenkai.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://guohenkai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>nvm安装使用</title>
    <link href="https://guohenkai.github.io/2021/07/31/nvm%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://guohenkai.github.io/2021/07/31/nvm安装使用/</id>
    <published>2021-07-30T16:00:00.000Z</published>
    <updated>2022-10-17T10:49:27.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在实际的前端开发过程中，可能会经常遇见 node.js 的版本问题，不同的项目需要使用不同的 node.js 版本。</p>
<p>直接安装的话，只能安装和使用 node.js 的一个版本。可以使用 nvm 来安装和管理不同版本的 node.js。</p>
<p>nvm 是 Mac 下的 node.js 管理工具。可以通过 nvm 安装和切换不同版本的 node.js。在 Windows 下面，可以使用 nvmw 或者 nvm-windows</p>
<blockquote>
<p>如果有安装过node，最好进行卸载，因为自己安装的，nvm控制不了，会出现一些意想不到的报错，先安装nvm，再使用nvm命令安装需要的版本即可！</p>
</blockquote>
 <a id="more"></a>
<h3 id="Windows-下-nvm-安装"><a href="#Windows-下-nvm-安装" class="headerlink" title="Windows 下 nvm 安装"></a>Windows 下 nvm 安装</h3><p>安装步骤如下：（亲测可用）</p>
<p>到 github 上面下载。下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="external">https://github.com/coreybutler/nvm-windows/releases</a></p>
<p>下载完 nvm-setup.zip 之后解压，解压出来一个 nvm-setup.exe 文件<br>双击安装</p>
<p>打开 cmd ，输入 nvm 验证是否安装成功</p>
<blockquote>
<p>备注：<br>nvm-noinstall.zip ：绿色免安装版，但使用时需进行配置。<br>nvm-setup.zip ：安装版，推荐使用<br>node.js 安装路径（就是以后下载的不同版本 node.js 的安装路径，推荐不要放在 C 盘，不要有空格、特殊字符等）</p>
</blockquote>
<h3 id="Mac-下-nvm-安装"><a href="#Mac-下-nvm-安装" class="headerlink" title="Mac 下 nvm 安装"></a>Mac 下 nvm 安装</h3><p>(暂未实践)<br>可以使用 curl 命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.38.0/install.sh | bash</div></pre></td></tr></table></figure></p>
<p>也可以使用 wget 命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.38.0/install.sh | bash</div></pre></td></tr></table></figure></p>
<p>v0.38.0 是 nvm 的版本号。最新版本号可到 github 上面查看</p>
<p>当出现 Node Version Manager 时，说明已安装成功；</p>
<p>安装完成后，需要先关闭终端，再重新打开。</p>
<p>可以通过查看版本号的命令确认是否安装成功： nvm -v</p>
<p>如果出现 command not found: nvm ，可能是因为缺少 .bash_profile 文件导致的。继续如下步骤操作</p>
<p>切换到用户目录： cd ~<br>查看是否有 .bash_profile 文件： ls -a；若没有则新建，添加以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion</div></pre></td></tr></table></figure></p>
<p>如果安装了 oh my zsh ，则需要在 .zshrc 文件中添加配置信息<br>打开 ~/.zshrc 文件，在最下面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>nvm ls ：列出所有已安装的 node 版本</li>
<li>nvm list ：列出所有已安装的 node 版本</li>
<li>nvm list available ：显示所有可下载的版本</li>
<li>nvm install latest：安装最新版 node</li>
<li>nvm install [node版本号] ：安装指定版本 node</li>
<li>nvm uninstall [node版本号] ：删除已安装的指定版本</li>
<li>nvm use [node版本号] ：切换到指定版本 node</li>
<li>nvm current ：当前 node 版本</li>
<li>nvm unalias [别名] ：删除已定义的别名</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;在实际的前端开发过程中，可能会经常遇见 node.js 的版本问题，不同的项目需要使用不同的 node.js 版本。&lt;/p&gt;
&lt;p&gt;直接安装的话，只能安装和使用 node.js 的一个版本。可以使用 nvm 来安装和管理不同版本的 node.js。&lt;/p&gt;
&lt;p&gt;nvm 是 Mac 下的 node.js 管理工具。可以通过 nvm 安装和切换不同版本的 node.js。在 Windows 下面，可以使用 nvmw 或者 nvm-windows&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果有安装过node，最好进行卸载，因为自己安装的，nvm控制不了，会出现一些意想不到的报错，先安装nvm，再使用nvm命令安装需要的版本即可！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="node" scheme="https://guohenkai.github.io/categories/node/"/>
    
    
      <category term="node" scheme="https://guohenkai.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>深入理解umi搭建的项目</title>
    <link href="https://guohenkai.github.io/2021/06/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3umi%E6%90%AD%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>https://guohenkai.github.io/2021/06/27/深入理解umi搭建的项目/</id>
    <published>2021-06-26T16:00:00.000Z</published>
    <updated>2022-10-17T10:45:06.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>根据  UmiJS  （乌米）搭建的前端应用框架，需要了解具体配置请查看以下文档。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">├── config 							env 环境配置和路由配置						</div><div class="line">├── mock</div><div class="line">├── public</div><div class="line">└── src</div><div class="line">    ├── .umi</div><div class="line">    ├── assets						图片资源</div><div class="line">    ├── config						全局配置相关，所有的 api 和 error 都在这个文件夹内</div><div class="line">    ├── components   		全局组件</div><div class="line">    ├── language   			语言配置</div><div class="line">    ├── hoc   						高阶组件</div><div class="line">    ├── layouts   				布局组件</div><div class="line">    ├── models           dva 相关</div><div class="line">    ├── pages						页面</div><div class="line">        ├── index.less</div><div class="line">        └── index.js</div><div class="line">    ├── service  				请求相关配置		</div><div class="line">    ├── styles  				  全局样式配置	</div><div class="line">    ├── utils						公共方法</div><div class="line">    ├── document.ejs			HTML 模板 引入外部资源,例如阿里 iconfont, 神策埋点</div><div class="line">    └── app.js</div><div class="line">├── .gitlab-ci.yml				gitlab runner 配置				</div><div class="line">├── package.json</div><div class="line">├── version.json  			  打包版本和环境配置</div></pre></td></tr></table></figure>
 <a id="more"></a>
<h2 id="开发配置"><a href="#开发配置" class="headerlink" title="开发配置"></a>开发配置</h2><h3 id="增加环境和后端服务配置"><a href="#增加环境和后端服务配置" class="headerlink" title="增加环境和后端服务配置"></a>增加环境和后端服务配置</h3><h4 id="增加环境"><a href="#增加环境" class="headerlink" title="增加环境"></a>增加环境</h4><ol>
<li>在项目中config -&gt; env 目录下增加对应环境的文件，例如：增加 test10.js 文件</li>
<li><p>在新加的文件中把各种全局变量配置好，可以参考之前配置的好的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export default &#123;</div><div class="line">  PUBLIC_URL: &apos;https://test10.coolcollege.cn&apos;,</div><div class="line">  CL_PLATFORM_API: &apos;https://t10platformapi.coolcollege.cn&apos;,</div><div class="line">  CL_ENTERPRISE_API: &apos;https://t10enterpriseapi.coolcollege.cn&apos;,</div><div class="line">  CL_EXAM_API: &apos;https://t10examapi.coolcollege.cn&apos;,</div><div class="line">   ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>在config -&gt; env -&gt; index.js中导出对应的环境的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import dev from &apos;./dev&apos;;</div><div class="line">import dev2 from &apos;./dev2&apos;;</div><div class="line">import test9 from &apos;./test9&apos;;</div><div class="line">import test10 from &apos;./test10&apos;;</div><div class="line"></div><div class="line">const getEnv = (env: string | undefined, name: string) =&gt; &#123;</div><div class="line">  switch (env) &#123;</div><div class="line">    case &apos;dev&apos;:</div><div class="line">      return dev;</div><div class="line">    case &apos;dev2&apos;:</div><div class="line">      return dev2;</div><div class="line">    case &apos;test9&apos;:</div><div class="line">      return test9;</div><div class="line">    case &apos;test10&apos;:</div><div class="line">      return test10;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    default:</div><div class="line">      return dev;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">export default getEnv;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="增加后端服务域名配置"><a href="#增加后端服务域名配置" class="headerlink" title="增加后端服务域名配置"></a>增加后端服务域名配置</h4><ol>
<li><p>在项目中config -&gt; env 目录下找到对应的开发环境，添加全局变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> export default &#123;</div><div class="line">  PUBLIC_URL: &apos;https://test7.coolcollege.cn&apos;,</div><div class="line">  CL_PLATFORM_API: &apos;https://t7platformapi.coolcollege.cn&apos;,</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  CL_CMS_API: &apos;https://tcmsapi.coolcollege.cn&apos;, // 新加的服务域名</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>在项目里 src -&gt; config -&gt; api.js  中配置接口地址；例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const RE_CL_CMS_API = CL_CMS_API;</div><div class="line"></div><div class="line">const CONFIG = &#123;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">  // CMS相关</div><div class="line">  CMSApi: &#123;</div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * @returns 简介：通过机构信息获得页面详情t</div><div class="line">     */</div><div class="line">    getPageScope: (t) =&gt; `$&#123;RE_CL_CMS_API&#125;/cms/v1/enterprises/cmsPage/$&#123;t.enterpriseId&#125;/getPageDetailByScope`,</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">export default CONFIG;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="接口请求相关配置"><a href="#接口请求相关配置" class="headerlink" title="接口请求相关配置"></a>接口请求相关配置</h3><h4 id="在项目里-src-gt-config-gt-api-js-中配置接口地址，按模块放置；例如："><a href="#在项目里-src-gt-config-gt-api-js-中配置接口地址，按模块放置；例如：" class="headerlink" title="在项目里 src -&gt; config -&gt; api.js  中配置接口地址，按模块放置；例如："></a>在项目里 src -&gt; config -&gt; api.js  中配置接口地址，按模块放置；例如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 培训日志</div><div class="line">operationLog: &#123;</div><div class="line">  getAudits:  () =&gt; `$&#123;RE_CL_FEED_API&#125;/v2/$&#123;CONFIG.enterpriseId&#125;/audits`,</div><div class="line">&#125;,</div><div class="line">// 多端登录</div><div class="line">multiTerminalLogin: &#123;</div><div class="line">  getWXStatus: () =&gt; `$&#123;RE_CL_ENTERPRISE_API&#125;/oa/id_for_name/tab_show_status`,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h4 id="在开发的文件夹中新建-service-文件夹，统一将该模块的接口放到这个文件夹的-index-js-文件内，注意每个接口加注释。例如"><a href="#在开发的文件夹中新建-service-文件夹，统一将该模块的接口放到这个文件夹的-index-js-文件内，注意每个接口加注释。例如" class="headerlink" title="在开发的文件夹中新建 service 文件夹，统一将该模块的接口放到这个文件夹的  index.js 文件内，注意每个接口加注释。例如:"></a>在开发的文件夹中新建 service 文件夹，统一将该模块的接口放到这个文件夹的  index.js 文件内，注意每个接口加注释。例如:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import CONFIG from &apos;@/config&apos;</div><div class="line">import &#123; request &#125; from &apos;@/service/index&apos;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @desc 获取导师辅导详情</div><div class="line"> * @param &#123;String&#125; tutorialsId 辅导任务id</div><div class="line"> * @param &#123;String&#125; tutorUserId  导师id</div><div class="line"> * @param &#123;String&#125; userId 学员id</div><div class="line"> */</div><div class="line">export function getTutorialDetails(&#123;tutorialsId, tutorUserId, userId&#125;) &#123;</div><div class="line">  const url = CONFIG.tutor.getCoachDetail(&#123;</div><div class="line">    tutorialsId,</div><div class="line">    tutorUserId,</div><div class="line">    userId</div><div class="line">  &#125;)</div><div class="line">  return request.get(&#123; url, params: &#123; status: &apos;single&apos; &#125; &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @desc 通过导师id获取导师详情数据</div><div class="line"> * @param &#123;String&#125; tutorId 导师id</div><div class="line"> */</div><div class="line">export function getTutorInfoById(tutorId) &#123;</div><div class="line">  const url = CONFIG.tutor.queryTutor(tutorId)</div><div class="line">  return request.get(&#123; url &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="全局错误提示配置"><a href="#全局错误提示配置" class="headerlink" title="全局错误提示配置"></a>全局错误提示配置</h3><h4 id="新接口错误处理提示配置"><a href="#新接口错误处理提示配置" class="headerlink" title="新接口错误处理提示配置"></a>新接口错误处理提示配置</h4><ul>
<li>在项目中 src -&gt; service-&gt; request.js中全局处理接口返回的错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">handleError(error) &#123;</div><div class="line">  if (error.response.status &amp;&amp; error.response.status === 401) &#123;</div><div class="line">    history.push(&apos;/&apos;);</div><div class="line">  &#125;</div><div class="line">  if (error.response.status &amp;&amp; error.response.status &gt;= 400) &#123;</div><div class="line">    if (error.response.data.code === &apos;enterpriseapi.542003&apos;) &#123;</div><div class="line">      // Resources are not exist</div><div class="line">    &#125; else if (error.response.data.code === &apos;openapi.common.002&apos;) &#123;</div><div class="line">      // openApi 403</div><div class="line">      // 什么都不做，防止通用设置openApi报错。不要删除</div><div class="line">    &#125; else if (</div><div class="line">      error.response.data.code &amp;&amp;</div><div class="line">      errorInfo[error.response.data.code] &amp;&amp;</div><div class="line">      errorInfo[error.response.data.code].showErrorMessage</div><div class="line">    ) &#123;</div><div class="line">      message.error(errorInfo[error.response.data.code].content);</div><div class="line">    &#125; else if (</div><div class="line">      error.response.data.code &amp;&amp;</div><div class="line">      errorInfo[error.response.data.code] &amp;&amp;</div><div class="line">      !errorInfo[error.response.data.code].showErrorMessage</div><div class="line">    ) &#123;</div><div class="line">      return Promise.reject(error);</div><div class="line">    &#125; else if (error.response.data.error) &#123;</div><div class="line">      const &#123; code &#125; = error.response.data.error;</div><div class="line">      if (errorInfo[code] &amp;&amp; errorInfo[code].showErrorMessage) &#123;</div><div class="line">        message.error(errorInfo[code].content);</div><div class="line">      &#125; else &#123;</div><div class="line">        return Promise.reject(error);</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      message.error(&apos;网络通信错误&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return Promise.reject(error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在项目里 src -&gt; config -&gt; error.js  中配置接口返回的错误码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">export default &#123; </div><div class="line">  &apos;enterpriseapi.4001&apos;: &#123;</div><div class="line">    message:          &apos;resource not found&apos;,</div><div class="line">    content:          &apos;资源不存在&apos;,</div><div class="line">    showErrorMessage: true,</div><div class="line">  &#125;,</div><div class="line">  &apos;enterpriseapi.404002&apos;: &#123;</div><div class="line">    message:          &apos;resource not found&apos;,</div><div class="line">    content:          &apos;资源不存在&apos;,</div><div class="line">    showErrorMessage: true,</div><div class="line">  &#125;,</div><div class="line">  &apos;enterpriseapi.4061&apos;: &#123;</div><div class="line">    message:          &apos;occupied by task&apos;,</div><div class="line">    content:          &apos;资源已被任务引用&apos;,</div><div class="line">    showErrorMessage: false, </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="老接口错误处理提示配置"><a href="#老接口错误处理提示配置" class="headerlink" title="老接口错误处理提示配置"></a>老接口错误处理提示配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// code 为 0 是正常， code 为 1 直接提示后端返回的错误提示信息  </div><div class="line">handleSuccess(response) &#123;</div><div class="line">    const res = response.data;</div><div class="line">    if (res.code === 1) &#123;</div><div class="line">      if (res.msg) &#123;</div><div class="line">        message.error(res.msg);</div><div class="line">      &#125; else &#123;</div><div class="line">        message.error(&apos;网络通讯错误&apos;);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (res.code === 112) &#123;</div><div class="line">      // 学习任务、考试任务中新增编辑，资源不存在的错误处理，已经catch</div><div class="line">      return Promise.reject(&apos;error&apos;);</div><div class="line">    &#125;</div><div class="line">    return response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><h4 id="学员端和后台管理路由"><a href="#学员端和后台管理路由" class="headerlink" title="学员端和后台管理路由"></a>学员端和后台管理路由</h4><p>isWhichHeader： ‘Trainee’, 表示为学员端路由; ‘manage’,  表示为管理端路由， 这个变量控制 header 的显示学员端的头还是管理端的头</p>
<h4 id="布局方式"><a href="#布局方式" class="headerlink" title="布局方式"></a>布局方式</h4><p>layoutType ：页面布局使用的方式有三种 LAYOUT_FULLSCREEN LAYOUT_COMMON LAYOUT_HASSLDEBAR</p>
<ul>
<li>LAYOUT_FULLSCREEN  —— 全屏，例如数据大屏页面，视频课程观看页面等</li>
<li>LAYOUT_HASSLDEBAR  —— 带侧边栏的，比如任务列表等</li>
<li>LAYOUT_COMMON  —— 带header的，比如新增试卷等<h4 id="菜单数据来源"><a href="#菜单数据来源" class="headerlink" title="菜单数据来源"></a>菜单数据来源</h4></li>
</ul>
<p>前端菜单路由是根据后端返回的菜单配置的，开发的时候确保和后端返回的菜单的 key 一致，否则进入 404 页面，后端返回的数据处理后存在  Local Storage 中</p>
<ul>
<li>管理端的菜单 =&gt; modules</li>
<li>学员端的菜单 =&gt; traineeModules<h4 id="路由修改"><a href="#路由修改" class="headerlink" title="路由修改"></a>路由修改</h4></li>
</ul>
<p>在项目中config -&gt; routes.js 文件中修改，路由配置文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">const allRoute = [</div><div class="line">  &#123;</div><div class="line">    path: &apos;/login&apos;,</div><div class="line">    title:       &apos;登录&apos;,</div><div class="line">    component: &apos;@/pages/login/index&apos;,</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    path: &apos;/&apos;,</div><div class="line">    component: &apos;@/layouts/SecurityLayout&apos;, // 鉴权登录页面</div><div class="line">    routes: [</div><div class="line">      // isWhichHeader:    &apos;Trainee&apos;, 表示为学院端路由</div><div class="line">      // isWhichHeader:    &apos;manage&apos;,  表示为管理端路由</div><div class="line">      &#123;</div><div class="line">        path: &apos;/&apos;,</div><div class="line">        component: &apos;@/layouts/BasicLayout&apos;,</div><div class="line">        routes:[</div><div class="line">          &#123;</div><div class="line">            path: &apos;/home&apos;,</div><div class="line">            title:       &apos;首页&apos;,</div><div class="line">            layoutType:       LAYOUT_COMMON,</div><div class="line">            isHeaderMenuItem: false,</div><div class="line">            headerMenuKey:    &apos;home&apos;,</div><div class="line">            menuKey:          &apos;home&apos;,</div><div class="line">            isWhichHeader:    &apos;Trainee&apos;,</div><div class="line">            isWhiteList:      true,</div><div class="line">            component: &apos;@/pages/trainee&apos;,</div><div class="line">          &#125;,</div><div class="line">          &#123; component: &apos;./404&apos; &#125;,</div><div class="line">        ]</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      &#123; component: &apos;./404&apos; &#125;,</div><div class="line">    ],</div><div class="line">  &#125;,</div><div class="line">  &#123; component: &apos;./404&apos;&#125;,</div><div class="line">];</div></pre></td></tr></table></figure></p>
<h3 id="主题色配置"><a href="#主题色配置" class="headerlink" title="主题色配置"></a>主题色配置</h3><ul>
<li>PC端项目使用的 Ant Design UI 组件库，不要随便更改 Ant Design 组件的默认颜色，如字体和背景色等，已经统一配置</li>
<li>hover和antd等行内无法解决的样式参考下面的包里的readme来使用mini-dynamic-antd-theme-enterprise</li>
<li>主题色在 localStorage和 redux里面都存了， 在里面封装了取颜色方法可以直接调用，使用方法如下：<br>a. 使用定义好的主题色类名 cl-primary<br>b. 使用 utils &gt; theme.js 里的 getThemeColor 方法获取主题色<br>c. 从 localStorage获取主题色<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;</div><div class="line">// 引入获取主题色方法</div><div class="line">import &#123; getThemeColor &#125; from &apos;@/utils/theme&apos;</div><div class="line"></div><div class="line">class Latoja extends React.Component &#123;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    // 1. 使用定义好的类名 `cl-primary`</div><div class="line">    // 2. 使用 utils/theme 里的 getThemeColor 方法获取主题色</div><div class="line">    const color = getThemeColor()</div><div class="line">    // 3. 从 localStorage 获取</div><div class="line">    // const themeColor = localStorage.getItem(&apos;themeColor&apos;) || &apos;#516ae6&apos;</div><div class="line">    return (</div><div class="line"> 		&lt;h1 className=&apos;title&apos;&gt;</div><div class="line">            &lt;span style=&#123;&#123;color&#125;&#125;&gt;讲师名称&lt;/span&gt;</div><div class="line">            &lt;span className=&apos;cl-primary&apos;&gt;主题色&lt;/span&gt;</div><div class="line">        &lt;/h1&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default withTranslation()(Latoja)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>需求开发过程中需要注意国际化，需要注意以下几点：</p>
<ol>
<li>词条一般使用 key:value的形式添加，</li>
<li>各个模块都有自己自身的词条，当前开发的需求在哪个模块词条就更新在当前的模块内</li>
<li><code>common</code> 模块里都是通用的词条，如果是全局通用的词条最好添加到这个模块内</li>
<li>添加词条前最好搜一下是否已经存在该词条，不要重复添加</li>
<li>修改词条的时候注意影响范围，很可能被多个地方引用</li>
<li>所有的文案都需要翻译成中文简体、中文繁体、英语三种语言，配置完成后需要切换语言看是否生效，样式是否错乱</li>
<li>页面和组件内使用国际化<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;</div><div class="line">// 引入 withTranslation</div><div class="line">import &#123; withTranslation &#125; from &apos;react-i18next&apos;</div><div class="line">// 替换字符 %s </div><div class="line">import &#123; sprinf &#125; from &apos;@/utils/toolFun&apos;</div><div class="line">class Example extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; t &#125; = this.props</div><div class="line">    const limit_count = 6</div><div class="line">    // 使用 t() 方法， </div><div class="line">    // 不需要传参的国际化  t(&apos;common.register&apos;) 立即报名</div><div class="line">    // 需要传参的国际化 sprinf(t(&apos;common.limitedPeopleCount&apos;), limit_count)  限6人</div><div class="line">    return (</div><div class="line">      &lt;div className=&apos;title&apos;&gt;</div><div class="line">      	&#123;t(&apos;common.register&apos;)&#125; (&#123;sprinf(t(&apos;common.limitedPeopleCount&apos;), limit_count)&#125;)</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">export default withTranslation()(Example)</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h2><h3 id="页面组件数据共享"><a href="#页面组件数据共享" class="headerlink" title="页面组件数据共享"></a>页面组件数据共享</h3><h4 id="使用-dva"><a href="#使用-dva" class="headerlink" title="使用 dva"></a>使用 dva</h4><ol>
<li>dva 的概念<br>数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State ，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致（也是来自于开源社区）。</li>
<li><p>umi 中已经集成了 dva，可以直接使用<br>在项目目录config -&gt; config.js 文件中开启 dva 配置，还有其他额外配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">export default defineConfig(&#123;</div><div class="line">  routes,</div><div class="line">  dva: &#123; hmr: true &#125;, // 开启 dva</div><div class="line">  define: &#123; REACT_APP_ENV, ...getEnv(env, name)&#125;,</div><div class="line">  history: &#123; type: &apos;hash&apos; &#125;,</div><div class="line">  theme: &#123;</div><div class="line">    &apos;@primary-color&apos;:            &apos;#516AE6&apos;,</div><div class="line">    &apos;@outline-width&apos;:            &apos;1px&apos;,</div><div class="line">    // left menu</div><div class="line">    &apos;@menu-dark-bg&apos;:             &apos;#5b658d&apos;,</div><div class="line">    &apos;@layout-header-background&apos;: &apos;#5b658d&apos;,</div><div class="line">    &apos;@menu-dark-submenu-bg&apos;:     &apos;#5b658d&apos;,</div><div class="line">    &apos;@menu-dark-item-active-bg&apos;: &apos;#516AE6&apos;,</div><div class="line">    &apos;@border-color-base&apos;:        &apos;#B2BAC4&apos;</div><div class="line">  &#125;,</div><div class="line">  publicPath: publicPath,</div><div class="line">  devtool: sourceMap,</div><div class="line">  locale: &#123;</div><div class="line">    antd: true</div><div class="line">  &#125;,</div><div class="line">  hash: true,</div><div class="line">  nodeModulesTransform: &#123;type: IS_BUILD ? &apos;all&apos; : &apos;none&apos;&#125;,</div><div class="line">  // favicon: &apos;static/favicon.ico&apos;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>使用方式</p>
</li>
</ol>
<ul>
<li>在项目 src -&gt; models 目录中新增一个文件courseClassify.js当作一个课程分类模块全局状态管理器</li>
<li>courseClassify.js文件内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">import &#123; request &#125; from &apos;@/service&apos;;</div><div class="line">import CONFIG from &apos;@/config&apos;;</div><div class="line"></div><div class="line">const APIs = &#123;</div><div class="line">  getClassifyList: CONFIG.Courses.getClassifyList,</div><div class="line">&#125;;</div><div class="line">// 示例</div><div class="line">function getClassifyTreeFun() &#123;</div><div class="line">  const params = &#123;</div><div class="line">    courseType: &apos;all&apos;,</div><div class="line">    queryType:  &apos;course_query&apos;</div><div class="line">  &#125;;</div><div class="line">  return request.get(&#123;</div><div class="line">    url: APIs.getClassifyList(),</div><div class="line">    params,</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // State 表示 Model 的状态数据，通常表现为一个 javascript 对象（当然它可以是任何值）；操作的时候每次都要当作不可变数据（immutable data）来对待，保证每次都是全新对象，没有引用关系，这样才能保证 State 的独立性，便于测试和追踪变化。</div><div class="line">    </div><div class="line">  state: &#123;</div><div class="line">    firstClassifyList: [],</div><div class="line">  &#125;,</div><div class="line">   // Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。</div><div class="line">   // Reducer 以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 state 的地方。由 action 触发。</div><div class="line">   // 格式为 (state, action) =&gt; newState 或 [(state, action) =&gt; newState, enhancer]。</div><div class="line">  reducers: &#123;</div><div class="line">    updateFirstClassify(state, action) &#123;</div><div class="line">      return &#123;</div><div class="line">        ...state,</div><div class="line">        firstClassify: action.payload,</div><div class="line">      &#125;;</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">  // Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。</div><div class="line">  // dva 为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而将effects转为纯函数。</div><div class="line">  // effects 以 key/value 格式定义 effect。用于处理异步操作和业务逻辑，不直接修改 state。由 action 触发，可以触发 action，可以和服务器交互，可以获取全局 state 的数据等等。例如请求课程分类回来后更新 state 中的 firstClassifyList 的值</div><div class="line">  effects: &#123;</div><div class="line">    *getClassifyTree(state, &#123; call, put, select &#125;) &#123;</div><div class="line">      // call 发起请求</div><div class="line">      const requeseData = yield call(getClassifyTreeFun);</div><div class="line">      if (requeseData) &#123;</div><div class="line">        // put 用于创建 dispatch Effect, 更新 state 的值</div><div class="line">        yield put(&#123; type: &apos;initFirstClassifyList&apos;, payload: requeseData.data.data &#125;);</div><div class="line">      &#125;</div><div class="line">      // select 用来获取 state 中的数据</div><div class="line">      console.log(yield select(state =&gt; state.courseClassify.firstClassifyList))</div><div class="line">      return requeseData</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>页面中获取 state 中的值和更新 state 中的值，示例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123; connect &#125; from &apos;dva&apos;;</div><div class="line">import &#123; withTranslation &#125; from &apos;react-i18next&apos;;</div><div class="line"></div><div class="line"></div><div class="line">class CourseClassify extends Component &#123;</div><div class="line">  clearClassifyPath = () =&gt; &#123;</div><div class="line">    const &#123; firstClassifyList, dispatch &#125; = this.props;</div><div class="line">    let allCourseClassify = firstClassifyList[0];</div><div class="line">     // 更新 courseClassify 模块内 state 的值，courseClassify 是模块名称 ，updateFirstClassify 是 reducers 内的方法 </div><div class="line">    dispatch(&#123;</div><div class="line">      type: &apos;courseClassify/updateFirstClassify&apos;,</div><div class="line">      payload: allCourseClassify,</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; visible &#125; = this.state;</div><div class="line">    const &#123; classifyPathList, t &#125; = this.props;</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;course-classify-container&quot;&gt;</div><div class="line">        &lt;div className=&quot;classify-path&quot;&gt;</div><div class="line">          &#123;classifyPathList.map((item, index) =&gt; &#123;</div><div class="line">                return item.id ? (</div><div class="line">                    &lt;span className=&quot;classify-path__path-name&quot; key=&#123;item.id&#125;&gt;</div><div class="line">                        &#123;item.name&#125;</div><div class="line">                    &lt;/span&gt;</div><div class="line">                ) : null;</div><div class="line">          &#125;)&#125;</div><div class="line">          &lt;div className=&quot;classify-path__clear-path&quot; onClick=&#123;this.clearClassifyPath&#125;&gt;</div><div class="line">            &#123;t(&apos;common.clear&apos;)&#125;</div><div class="line">          &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 获取 state 中的值，</div><div class="line">const mapStateToProps = state =&gt; (&#123;</div><div class="line">  classifyPathList: state.courseClassify.classifyPathList,</div><div class="line">&#125;);</div><div class="line">// 使用 connect 注入到当前组件的 props </div><div class="line">export default connect(mapStateToProps)(withTranslation()(CourseClassify));</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用-Context"><a href="#使用-Context" class="headerlink" title="使用 Context"></a>使用 Context</h4><pre><code>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。[参考](https://react.docschina.org/docs/context.html)
</code></pre><h3 id="组件开发规范"><a href="#组件开发规范" class="headerlink" title="组件开发规范"></a>组件开发规范</h3><h4 id="全局公用组件和页面内部组件"><a href="#全局公用组件和页面内部组件" class="headerlink" title="全局公用组件和页面内部组件"></a>全局公用组件和页面内部组件</h4><ul>
<li>全局组件是公用组件<blockquote>
<p>开发过程中记得先去查看是否已经实现了该组件，避免做重复工作，重复造轮子，例如全局组件中的：ClDocReader、ClHeader 等</p>
</blockquote>
</li>
<li>内部组件供页面内部使用，即不通用的组件<blockquote>
<p>即每个页面或者表单页有自己内部和业务有耦合的组件，例如： pk =&gt; components  =&gt; pkUserList 组件</p>
</blockquote>
</li>
</ul>
<h4 id="业务组件和非业务组件"><a href="#业务组件和非业务组件" class="headerlink" title="业务组件和非业务组件"></a>业务组件和非业务组件</h4><ul>
<li>业务组件是和业务相关的组件，即里面涉及到和数据交互<blockquote>
<p>例如：选人组件 OrgDialog</p>
</blockquote>
</li>
<li>非业务组件<blockquote>
<p>例如： table操作列按钮封装 TableOperateColumn，弹窗组件ClModal</p>
</blockquote>
</li>
</ul>
<h4 id="组件开发注意事项"><a href="#组件开发注意事项" class="headerlink" title="组件开发注意事项"></a>组件开发注意事项</h4><ol>
<li>组件名必须以大驼峰式命名法（upper camel case），组件文件夹命名全部采用小写方式， 以中划线分隔（后续会有组件开发规范文档）</li>
<li>全局组件引入组件的时候不要引入页面内部组件</li>
<li>组件开发需要注意加 defaultProps 和 propTypes,需要清楚的描述相关字段的作用。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">DocReader.defaultProps = &#123;</div><div class="line">  type:           &apos;&apos;, // 来源 课程，任务，课件预览</div><div class="line">  docType:        &apos;&apos;, // 文档类型 例如：ppt doc等</div><div class="line">  aliUrl:         &apos;&apos;, // 新文档预览地址 path</div><div class="line">  url:            &apos;&apos;, // 365文档预览地址 url</div><div class="line">  isSaveProgress: true, // 是否保存进度</div><div class="line">  studyId:        &apos;&apos;, // 任务的 id</div><div class="line">  courseId:       &apos;&apos;, // 任务下 item 的 courseId</div><div class="line">  resourceId:     &apos;&apos;, // 资源id 如果任务下都是课件则 courseId 和 resourceId 是相同的， 都是当前课件的 courseId， 如果是课程的话 resourceId 就是每个课件的 id</div><div class="line">  docTitle:       &apos;&apos;, // 文档的名称</div><div class="line">  studyTimeLimit: 0, // 文档倒计时的标识， 文档的每页学习时长 大于 0 则开启倒计时</div><div class="line">  studyTime:      0, // 文档倒计时的时候把 recentStart 作为文档剩余学习时长传给文档服务器</div><div class="line">  progress:       0, // 文档的进度</div><div class="line">&#125;;</div><div class="line"></div><div class="line">DocReader.propTypes = &#123;</div><div class="line">  type:     PropTypes.string.isRequired, // 来源 课程，任务，课件预览 enterprise platform study &apos;&apos;</div><div class="line">  docType:  PropTypes.string.isRequired, // 文档类型</div><div class="line">  aliUrl:   PropTypes.string.isRequired, // 新文档预览地址</div><div class="line">  url:      PropTypes.string.isRequired, // 365文档预览地址</div><div class="line">  docTitle: PropTypes.string.isRequired, // 文档名称</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用频率较高的组件和方法"><a href="#使用频率较高的组件和方法" class="headerlink" title="使用频率较高的组件和方法"></a>使用频率较高的组件和方法</h3><h4 id="NewTabLink-新开窗口"><a href="#NewTabLink-新开窗口" class="headerlink" title="NewTabLink 新开窗口"></a>NewTabLink 新开窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import NewTabLink from &apos;@/components/NewTabLink&apos;</div><div class="line"></div><div class="line">export default function Example() &#123;</div><div class="line">  // 新开内部页面窗口</div><div class="line">  const linkTo = ()=&gt; &#123;</div><div class="line">     NewTabLink.targetTo(&#123;</div><div class="line">       path: `/lecturer/lecturerManage/lecturerList`,</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  // 外部链接新开窗口打开, isExternalLink 是外部链接，具体逻辑可以查看 NewTabLink 这个组件</div><div class="line">  const operatingGuide = () =&gt; &#123;</div><div class="line">    NewTabLink.targetTo(&#123;</div><div class="line">      path:           &apos;https://www.yuque.com/books/share/4dc0b2ad-3bda-4631-8584-e5f94b48b861?#&apos;,</div><div class="line">      isExternalLink: true,</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  return (&lt;div&gt;</div><div class="line">      &lt;div onClick=&#123;linkTo&#125;&gt; 新开页面 &lt;/div&gt;</div><div class="line">      &lt;div onClick=&#123;operatingGuide&#125;&gt; 打开指南 &lt;/div&gt;</div><div class="line">      &#123;/* 新开内部页面窗口 */&#125;</div><div class="line">      &lt;NewTabLink to=&quot;/lecturer/lecturerManage/lecturerList&quot;&gt;新开页面&lt;/NewTabLink&gt;</div><div class="line">   &lt;/div&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><ol>
<li>获取当前菜单对应的按钮权限：src -&gt; utils -&gt; moduleWorkflow.js</li>
</ol>
<ul>
<li><p>获取当前菜单下的按钮信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// `tutorList` 是当前菜单的 key, `modules` 是从后端接口请求回来的用户菜单信息</div><div class="line">const allowActions = getPermissionActionsByKey(&apos;tutorList&apos;, props.modules)</div></pre></td></tr></table></figure>
</li>
<li><p>从菜单获取的按钮信息中获取当前按钮是否显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 根据菜单获取的按钮，再获取编辑按钮是否显示</div><div class="line">const shouldRenderEditBtn = getPermissionRenderByKey(&apos;edit&apos;, allowActions)</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>获取正在下载中的文件： src -&gt; utils -&gt; globalRequest.js全局请求</p>
</li>
<li><p>钉钉相关：src -&gt; utils -&gt; dd.js<br>a. 钉钉 API 调用鉴权：getJsApisSignature<br>b. 钉功能： Ding<br>c. 钉盘文件预览： previewDingFile</p>
</li>
</ol>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p> 为了解决样式冲突问题</p>
<ol>
<li><p>每个页面或组件使用唯一变量作为容器类名，为了避免全局样式污染，使用 __ 或  —连接，包裹在主容器样式里，防止样式冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.classify-container-wrapper &#123;</div><div class="line">    display: flex;</div><div class="line">    flex-direction: column;</div><div class="line">    flex: 1;</div><div class="line">    &amp;__content &#123;</div><div class="line">      flex: 1;</div><div class="line">      padding: 24px 32px 32px;</div><div class="line">      overflow: hidden;</div><div class="line">      background: #fff;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用 css module 的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123; DragSource &#125; from &apos;react-dnd&apos;;</div><div class="line"></div><div class="line">import style from &apos;./index.less&apos;;</div><div class="line"></div><div class="line">const ComponentLeft = (materialKeys) =&gt; &#123;</div><div class="line"></div><div class="line">  return (</div><div class="line">    &lt;div className=&#123;style.leftContent&#125;&gt;</div><div class="line">      &lt;div className=&#123;style.leftTitle&#125;&gt;</div><div class="line">        &lt;h3&gt;组件库&lt;/h3&gt;</div><div class="line">        &lt;p className=&#123;style.desc&#125;&gt;拖拽下方模块添加到右侧布局中&lt;/p&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  )</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default ComponentLeft;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><p>根据 Ant Design 组件的规范开发</p>
<blockquote>
<p>如果设计图出现和 Ant Design 的组件规范不符合的，可以直接找设计修改设计图，一定不要随便更改 Ant Design 组件自身的样式</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;根据  UmiJS  （乌米）搭建的前端应用框架，需要了解具体配置请查看以下文档。&lt;/p&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── config 							env 环境配置和路由配置						&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── mock&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── public&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;└── src&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── .umi&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── assets						图片资源&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── config						全局配置相关，所有的 api 和 error 都在这个文件夹内&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── components   		全局组件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── language   			语言配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── hoc   						高阶组件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── layouts   				布局组件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── models           dva 相关&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── pages						页面&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ├── index.less&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        └── index.js&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── service  				请求相关配置		&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── styles  				  全局样式配置	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── utils						公共方法&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── document.ejs			HTML 模板 引入外部资源,例如阿里 iconfont, 神策埋点&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    └── app.js&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── .gitlab-ci.yml				gitlab runner 配置				&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── package.json&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── version.json  			  打包版本和环境配置&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="umi" scheme="https://guohenkai.github.io/categories/umi/"/>
    
    
      <category term="umi" scheme="https://guohenkai.github.io/tags/umi/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 的 esLint 配置同步</title>
    <link href="https://guohenkai.github.io/2021/06/06/VScode%E7%9A%84esLint%E9%85%8D%E7%BD%AE%E5%90%8C%E6%AD%A5/"/>
    <id>https://guohenkai.github.io/2021/06/06/VScode的esLint配置同步/</id>
    <published>2021-06-05T16:00:00.000Z</published>
    <updated>2022-10-17T10:16:14.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VSCode-的-xxLint-配置同步"><a href="#VSCode-的-xxLint-配置同步" class="headerlink" title="VSCode 的 xxLint 配置同步"></a>VSCode 的 xxLint 配置同步</h3><h4 id="Settings-Sync-一键配置-VSCode"><a href="#Settings-Sync-一键配置-VSCode" class="headerlink" title="Settings Sync 一键配置 VSCode"></a>Settings Sync 一键配置 VSCode</h4><p>1、IDE - VSCode</p>
<p>1.1、下载  VSCode 扩展工具  Settings Sync</p>
<p>1.2、 快捷键  Shift + Alt + D 或  macOS： Shift + Option + D 打开 Settings Sync 工具欢迎页</p>
<p>1.3、点击页面的 ‘Download Public Gist’ ,在顶部弹出输入框中输入4dd2f1554fd3c3fa6aebf5c295103fd1后，点击回车即可。操作结束后可在 VSCode 输出控制台查看同步情况<br> <a id="more"></a></p>
<p><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78g9y1rdcj20si0h6454.jpg" alt="1595410269004.png"></p>
<blockquote>
<p>备注：若没有‘Download Public Gist’，先Ctrl+Shift+P，搜sync，重置一下，继续重复1.2步骤</p>
</blockquote>
<p>操作完成后 ESLint 为生效？？</p>
<p>有时项目依赖包的安装过程中遗漏部分包也会导致 ESLint 不生效，尝试换成 cnpm 命令重新安装依赖包</p>
<p>操作完成后注意 VSCode 右下角的  ESLint 小图标  ，只有该图标如下图显示小对勾时才说明配置的 ESLint 真正生效了<br><img src="http://tva1.sinaimg.cn/large/e0823b04ly1h78gah8fbjj20ku0ban04.jpg" alt="微信图片_20200817201915.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;VSCode-的-xxLint-配置同步&quot;&gt;&lt;a href=&quot;#VSCode-的-xxLint-配置同步&quot; class=&quot;headerlink&quot; title=&quot;VSCode 的 xxLint 配置同步&quot;&gt;&lt;/a&gt;VSCode 的 xxLint 配置同步&lt;/h3&gt;&lt;h4 id=&quot;Settings-Sync-一键配置-VSCode&quot;&gt;&lt;a href=&quot;#Settings-Sync-一键配置-VSCode&quot; class=&quot;headerlink&quot; title=&quot;Settings Sync 一键配置 VSCode&quot;&gt;&lt;/a&gt;Settings Sync 一键配置 VSCode&lt;/h4&gt;&lt;p&gt;1、IDE - VSCode&lt;/p&gt;
&lt;p&gt;1.1、下载  VSCode 扩展工具  Settings Sync&lt;/p&gt;
&lt;p&gt;1.2、 快捷键  Shift + Alt + D 或  macOS： Shift + Option + D 打开 Settings Sync 工具欢迎页&lt;/p&gt;
&lt;p&gt;1.3、点击页面的 ‘Download Public Gist’ ,在顶部弹出输入框中输入4dd2f1554fd3c3fa6aebf5c295103fd1后，点击回车即可。操作结束后可在 VSCode 输出控制台查看同步情况&lt;br&gt;
    
    </summary>
    
      <category term="规范" scheme="https://guohenkai.github.io/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="规范" scheme="https://guohenkai.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>前端开发规范（React项目开发规范）</title>
    <link href="https://guohenkai.github.io/2021/05/29/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%EF%BC%889%EF%BC%89/"/>
    <id>https://guohenkai.github.io/2021/05/29/前端开发规范（9）/</id>
    <published>2021-05-28T16:00:00.000Z</published>
    <updated>2022-10-17T08:35:54.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><ul>
<li>每个文件只包含一个 React 类组件 <ul>
<li>但是多个函数式组件可以放到一个文件中，eslint: react/no-multi-comp</li>
</ul>
</li>
<li>如果使用 JavaScript，则文件扩展名为 .jsx；如果使用 TypeScript，则文件扩展名为 .tsx</li>
<li>除非是在非 JSX 文件中初始化应用，否则不要使用 React.createElement</li>
<li>只允许使用 Class Component 和 Functional Component 两种形态来书写组件，建议尽量使用函数式组件配合 Hooks 来进行开发，没有state的组件生命为函数组件。</li>
</ul>
<a id="more"></a>
<h3 id="组件规范"><a href="#组件规范" class="headerlink" title="组件规范"></a>组件规范</h3><ul>
<li>对于所有非isRequired的属性，在defaultProps中声明对应的值；声明初始值有助于对组件初始状态的理解，也可以减少propTypes对类型进行校验产生的开销。对于初始没有值的属性，应当声明初始值为null而非undefined。</li>
<li>[建议]将JSX的层级控制在3层以内。JSX提供了基于组件的便携的复用形式，因此可以通过将结构中的一部分封装为一个函数组件来很好地拆分大型复杂的结构。层次过深的结构会带来过多缩进、可读性下降等缺点。如同控制函数内代码行数和分支层级一样，对JSX的层级进行控制可以有效提升代码的可维护性。</li>
</ul>
<h4 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h4><ul>
<li>React 组件使用 PascalCase，组件实例使用 CamelCase，eslint: react/jsx-pascal-case</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">import reservationCard from &apos;./ReservationCard&apos;</div><div class="line"></div><div class="line">// good</div><div class="line">import ReservationCard from &apos;./ReservationCard&apos;</div><div class="line"></div><div class="line">// bad</div><div class="line">const ReservationItem = &lt;ReservationCard /&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">const reservationItem = &lt;ReservationCard /&gt;</div></pre></td></tr></table></figure>
<ul>
<li>如果是组件文件，使用文件名全小写-分割，例如, reservation-card.js 应该包含名为 ReservationCard 的引用，然而对于文件夹中的根组件, 使用 index.js 作为文件名，使用文件夹的名字作为组件的名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// good</div><div class="line">import ReservationCard from &apos;./reservation-card/reservation-card&apos;</div><div class="line"></div><div class="line">// bad</div><div class="line">import Footer from &apos;./footer/index&apos;</div><div class="line"></div><div class="line">// good</div><div class="line">import Footer from &apos;./footer&apos;</div></pre></td></tr></table></figure>
<ul>
<li>组件的引用</li>
</ul>
<p>组件引用的路径除非是当前目录下的组件可以使用相对路径，其他的都使用绝对路径，src已添加路径别名，使用路径别名引入，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// good</div><div class="line">import MyComponent from &apos;./component/my-component&apos;</div><div class="line"></div><div class="line">// bad</div><div class="line">import MyComponent from &apos;../../../component/my-component&apos;</div><div class="line"></div><div class="line">// good</div><div class="line">import MyComponent from &apos;@/component/my-component&apos;</div></pre></td></tr></table></figure>
<ul>
<li>自闭合的标签前要加一个空格，eslint: no-multi-spaces, react/jsx-tag-spacing</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo/&gt;</div><div class="line"></div><div class="line">// very bad</div><div class="line">&lt;Foo                 /&gt;</div><div class="line"></div><div class="line">// bad</div><div class="line">&lt;Foo</div><div class="line"> /&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo /&gt;</div></pre></td></tr></table></figure>
<h4 id="组件属性"><a href="#组件属性" class="headerlink" title="组件属性"></a>组件属性</h4><ul>
<li>属性名使用 camelCase</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo</div><div class="line">  UserName=&apos;hello&apos;</div><div class="line">  phone_number=&#123;12345678&#125;</div><div class="line">/&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo</div><div class="line">  userName=&apos;hello&apos;</div><div class="line">  phoneNumber=&#123;12345678&#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<ul>
<li>当属性值为true时可以省略， eslint: react/jsx-boolean-value</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo</div><div class="line">  hidden=&#123;true&#125;</div><div class="line">/&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo</div><div class="line">  hidden</div><div class="line">/&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo hidden /&gt;</div></pre></td></tr></table></figure>
<ul>
<li>避免使用数组的索引作为 key 属性值, 建议使用稳定的ID，eslint: react/no-array-index-key</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&#123;todos.map((todo, index) =&gt;</div><div class="line">  &lt;Todo</div><div class="line">    &#123;...todo&#125;</div><div class="line">    key=&#123;index&#125;</div><div class="line">  /&gt;</div><div class="line">)&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">&#123;todos.map(todo =&gt; (</div><div class="line">  &lt;Todo</div><div class="line">    &#123;...todo&#125;</div><div class="line">    key=&#123;todo.id&#125;</div><div class="line">  /&gt;</div><div class="line">))&#125;</div></pre></td></tr></table></figure>
<ul>
<li>为所有的非必需属性定义使用 defaultProps 明确的默认值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">function SFC (&#123; foo, bar, children &#125;) &#123;</div><div class="line">  return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;</div><div class="line">&#125;</div><div class="line">SFC.propTypes = &#123;</div><div class="line">  foo: PropTypes.number.isRequired,</div><div class="line">  bar: PropTypes.string,</div><div class="line">  children: PropTypes.node</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function SFC (&#123; foo, bar, children &#125;) &#123;</div><div class="line">  return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;</div><div class="line">&#125;</div><div class="line">SFC.propTypes = &#123;</div><div class="line">  foo: PropTypes.number.isRequired,</div><div class="line">  bar: PropTypes.string,</div><div class="line">  children: PropTypes.node</div><div class="line">&#125;</div><div class="line">SFC.defaultProps = &#123;</div><div class="line">  bar: &apos;&apos;,</div><div class="line">  children: null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当 JSX 标签超过一行时使用圆括号包裹， eslint: react/wrap-multilines</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// bad</div><div class="line">render () &#123;</div><div class="line">  return &lt;MyComponent className=&apos;long body&apos; foo=&apos;bar&apos;&gt;</div><div class="line">           &lt;MyChild /&gt;</div><div class="line">         &lt;/MyComponent&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">render () &#123;</div><div class="line">  return (</div><div class="line">    &lt;MyComponent className=&apos;long body&apos; foo=&apos;bar&apos;&gt;</div><div class="line">      &lt;MyChild /&gt;</div><div class="line">    &lt;/MyComponent&gt;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good, when single line</div><div class="line">render () &#123;</div><div class="line">  const body = &lt;div&gt;hello&lt;/div&gt;</div><div class="line">  return &lt;MyComponent&gt;&#123;body&#125;&lt;/MyComponent&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>没有子元素的标签请自闭合，eslint: react/self-closing-comp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo className=&apos;stuff&apos;&gt;&lt;/Foo&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo className=&apos;stuff&apos; /&gt;</div></pre></td></tr></table></figure>
<ul>
<li>如果组件包含多行属性，在新的一行闭合标签，eslint: react/jsx-closing-bracket-location</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo</div><div class="line">  bar=&apos;bar&apos;</div><div class="line">  baz=&apos;baz&apos; /&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo</div><div class="line">  bar=&apos;bar&apos;</div><div class="line">  baz=&apos;baz&apos;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<ul>
<li>属性对齐，遵循以下JSX语法的对齐风格，eslint: react/jsx-closing-bracket-location</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo superLongParam=&apos;bar&apos;</div><div class="line">     anotherSuperLongParam=&apos;baz&apos; /&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo</div><div class="line">  superLongParam=&apos;bar&apos;</div><div class="line">  anotherSuperLongParam=&apos;baz&apos;</div><div class="line">/&gt;</div><div class="line"></div><div class="line">// if props fit in one line then keep it on the same line</div><div class="line">&lt;Foo bar=&apos;bar&apos; /&gt;</div><div class="line"></div><div class="line">// children get indented normally</div><div class="line">&lt;Foo</div><div class="line">  superLongParam=&apos;bar&apos;</div><div class="line">  anotherSuperLongParam=&apos;baz&apos;</div><div class="line">&gt;</div><div class="line">  &lt;Quux /&gt;</div><div class="line">&lt;/Foo&gt;</div><div class="line"></div><div class="line">// bad</div><div class="line">&#123;showButton &amp;&amp;</div><div class="line">  &lt;Button /&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// bad</div><div class="line">&#123;</div><div class="line">  showButton &amp;&amp;</div><div class="line">    &lt;Button /&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">&#123;showButton &amp;&amp; (</div><div class="line">  &lt;Button /&gt;</div><div class="line">)&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">&#123;showButton &amp;&amp; &lt;Button /&gt;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不要在 JSX 的花括号里边加空格，eslint: react/jsx-curly-spacing</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo bar=&#123; baz &#125; /&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo bar=&#123;baz&#125; /&gt;</div></pre></td></tr></table></figure>
<ul>
<li>引号：JSX 属性要使用单引号，与其他普通 JS 保持一致</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo bar=&quot;bar&quot; /&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo bar=&apos;bar&apos; /&gt;</div><div class="line"></div><div class="line">// bad</div><div class="line">&lt;Foo style=&#123;&#123; left: &quot;20px&quot; &#125;&#125; /&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo style=&#123;&#123; left: &apos;20px&apos; &#125;&#125; /&gt;</div></pre></td></tr></table></figure>
<h4 id="组件方法"><a href="#组件方法" class="headerlink" title="组件方法"></a>组件方法</h4><ul>
<li>类组件的内部方法不要使用下划线前缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">class extends React.Component &#123;</div><div class="line">  _onClickSubmit () &#123;</div><div class="line">    // do stuff</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // other stuff</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">class extends React.Component &#123;</div><div class="line">  onClickSubmit () &#123;</div><div class="line">    // do stuff</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // other stuff</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>确保在 render 方法中存在返回值，eslint: require-render-return</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">render () &#123;</div><div class="line">  (&lt;div /&gt;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">render () &#123;</div><div class="line">  return (&lt;div /&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用箭头函数包裹本地变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function ItemList (props) &#123;</div><div class="line">  return (</div><div class="line">    &lt;ul&gt;</div><div class="line">      &#123;props.items.map((item, index) =&gt; (</div><div class="line">        &lt;Item</div><div class="line">          key=&#123;item.key&#125;</div><div class="line">          onClick=&#123;() =&gt; doSomethingWith(item.name, index)&#125;</div><div class="line">        /&gt;</div><div class="line">      ))&#125;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>组件方法命名，组件方法使用handle开头，组件调用属性方法以on开头</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;MyComponent handleChange=&#123;this.handleChange&#125; /&gt;</div><div class="line">&lt;MyComponent onChange=&#123;this.componentChanged&#125; /&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;MyComponent onChange=&#123;this.handleChange&#125; /&gt;</div><div class="line">&lt;MyComponent onChange=&#123;this.props.onFoo&#125; /&gt;</div></pre></td></tr></table></figure>
<h4 id="组件内顺序"><a href="#组件内顺序" class="headerlink" title="组件内顺序"></a>组件内顺序</h4><p>按照以下顺序编排组件中的方法和属性：</p>
<ol>
<li>static state</li>
<li>constructor</li>
<li>其它静态的属性</li>
<li>getChildContext</li>
<li>componentWillMount</li>
<li>componentDidMount</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
<li>事件处理方法</li>
<li>其它方法</li>
<li>render其中shouldComponentUpdate和render是一个组件最容易被阅读的函数，因此放在最下方有助于快速定位。</li>
<li>state defaultProps</li>
<li>static propTypes</li>
<li>static contextTypes</li>
</ol>
<blockquote>
<p>可以在 Visual Studio Code 编辑器中添加 code snippets，没有用的方法删掉</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;</div><div class="line">import PropTypes from &apos;prop-types&apos;</div><div class="line">import &#123; Upload, Icon, Modal &#125; from &apos;antd&apos;</div><div class="line">import &#123; Cookie &#125; from &apos;utils&apos;</div><div class="line">import styles from &apos;./UploadFile.less&apos;</div><div class="line"></div><div class="line">const getFileList = (files) =&gt; &#123;</div><div class="line">  if (Array.isArray(files)) &#123;</div><div class="line">    return files.map((item, key) =&gt; &#123;</div><div class="line">      const urlArr = item.full_url.split(&apos;/&apos;)</div><div class="line">      return &#123; url: item.full_url, id: item.id, uid: key, name: urlArr[urlArr.length - 1], status: &apos;done&apos; &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  if (files &amp;&amp; !!files.length) &#123;</div><div class="line">    const filesArr = files.split(&apos;/&apos;)</div><div class="line">    return [&#123; uid: -1, url: files, name: filesArr[filesArr.length - 1], status: &apos;done&apos; &#125;]</div><div class="line">  &#125;</div><div class="line">  return &apos;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function renderAccecpt (accept) &#123;</div><div class="line">  if (!accept) &#123;</div><div class="line">    return null</div><div class="line">  &#125;</div><div class="line">  if ([&apos;image&apos;, &apos;video&apos;, &apos;audio&apos;].find(ext =&gt; ext === accept)) &#123;</div><div class="line">    return `$&#123;accept&#125;/*`</div><div class="line">  &#125;</div><div class="line">  if (accept === &apos;zip&apos;) &#123;</div><div class="line">    return &apos;application/zip,application/x-zip,application/x-zip-compressed&apos;</div><div class="line">  &#125;</div><div class="line">  return `.$&#123;accept&#125;`</div><div class="line">&#125;</div><div class="line"></div><div class="line">class UploadFiles extends Component &#123;</div><div class="line"></div><div class="line">  constructor (props) &#123;</div><div class="line">    super(props)</div><div class="line"></div><div class="line">    this.state = &#123;</div><div class="line">      previewVisible: false,</div><div class="line">      previewImage: &apos;&apos;,</div><div class="line">      files: getFileList(props.files),</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillReceiveProps (nextProps) &#123;</div><div class="line">    if (Array.isArray(this.props.files) &amp;&amp; !this.props.files.length &amp;&amp; !!nextProps.files.length) &#123;</div><div class="line">      this.setState(&#123; files: getFileList(nextProps.files) &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render () &#123;</div><div class="line">    const &#123; previewVisible, previewImage, files &#125; = this.state</div><div class="line"></div><div class="line">    const &#123; multiple = 1, onUpload, disabled, path, accept &#125; = this.props</div><div class="line"></div><div class="line">    const renderFiles = (fileList) =&gt; &#123;</div><div class="line">      const newFiles = fileList.map((file) =&gt; &#123;</div><div class="line">        return file.response ? file.response.data.file : file</div><div class="line">      &#125;)</div><div class="line">      if (multiple === 1) &#123;</div><div class="line">        return newFiles[0]</div><div class="line">      &#125;</div><div class="line">      return newFiles</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    let actionUrl = `$&#123;newband.app.admin.API_HOST&#125;v2/file/upload/formData?access_token=$&#123;Cookie.get(&apos;access_token&apos;)&#125;`</div><div class="line">    if (path) &#123;</div><div class="line">      actionUrl += `&amp;path=$&#123;path&#125;`</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const uploadProps = &#123;</div><div class="line">      accept: renderAccecpt(accept),</div><div class="line">      action: actionUrl,</div><div class="line">      headers: &#123;</div><div class="line">        &apos;X-Requested-With&apos;: null,</div><div class="line">      &#125;,</div><div class="line">      data: &#123;</div><div class="line">      &#125;,</div><div class="line">      disabled,</div><div class="line">      listType: &apos;picture-card&apos;,</div><div class="line">      fileList: files,</div><div class="line">      multiple: multiple === true,</div><div class="line">      onPreview: (file) =&gt; &#123;</div><div class="line">        this.setState(&#123;</div><div class="line">          previewImage: file.url || file.thumbUrl,</div><div class="line">          previewVisible: true,</div><div class="line">        &#125;)</div><div class="line">      &#125;,</div><div class="line">      beforeUpload: () =&gt; &#123;</div><div class="line">        return true</div><div class="line">      &#125;,</div><div class="line">      onChange: (&#123; file, fileList &#125;) =&gt; &#123;</div><div class="line">        this.setState(&#123; files: fileList &#125;)</div><div class="line">        if (file.percent === 100 &amp;&amp; file.status === &apos;done&apos;) &#123;</div><div class="line">          onUpload(renderFiles(fileList, 1))</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      onRemove: (file) =&gt; &#123;</div><div class="line">        if (disabled) &#123;</div><div class="line">          return false</div><div class="line">        &#125;</div><div class="line">        const fileList = this.state.files.filter(item =&gt; item.uid !== file.uid)</div><div class="line">        onUpload(renderFiles(fileList, 0))</div><div class="line">        return true</div><div class="line">      &#125;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const modalProps = &#123;</div><div class="line">      visible: previewVisible,</div><div class="line">      footer: null,</div><div class="line">      onCancel: () =&gt; this.setState(&#123; previewVisible: false &#125;),</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const uploadButton = (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;Icon type=&quot;plus&quot; /&gt;</div><div class="line">        &lt;div className=&quot;ant-upload-text&quot;&gt;点击上传&lt;/div&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line"></div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;clearfix&quot;&gt;</div><div class="line">        &lt;Upload &#123;...uploadProps&#125;&gt;</div><div class="line">          &#123;multiple === true ? uploadButton : (files.length &lt; multiple &amp;&amp; uploadButton)&#125;</div><div class="line">        &lt;/Upload&gt;</div><div class="line">        &lt;Modal &#123;...modalProps&#125;&gt;</div><div class="line">          &lt;img className=&#123;styles.previewImage&#125; alt=&quot;&quot; src=&#123;previewImage&#125; /&gt;</div><div class="line">        &lt;/Modal&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">  static defaultProps = &#123;</div><div class="line">    onUpload: ()=&gt;&#123;&#125;,</div><div class="line">    accept: &apos;image/*&apos;</div><div class="line">  &#125;</div><div class="line">  static propTypes = &#123;</div><div class="line">    files: PropTypes.oneOfType([PropTypes.array, PropTypes.string]),</div><div class="line">    onUpload: PropTypes.func.isRequired,</div><div class="line">    multiple: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),</div><div class="line">    disabled: PropTypes.bool,</div><div class="line">    path: PropTypes.string,</div><div class="line">    accept: PropTypes.string,</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default UploadFiles</div></pre></td></tr></table></figure>
<h3 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h3><p>避免使用字符串引用，请使用回调函数作为引用，eslint: react/no-string-refs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">&lt;Foo</div><div class="line">  ref=&apos;myRef&apos;</div><div class="line">/&gt;</div><div class="line"></div><div class="line">// good</div><div class="line">&lt;Foo</div><div class="line">  ref=&#123;ref =&gt; &#123; this.myRef = ref &#125;&#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<h3 id="Hooks-书写规范"><a href="#Hooks-书写规范" class="headerlink" title="Hooks 书写规范"></a>Hooks 书写规范</h3><ul>
<li>Hooks 只能应用于函数式组件中 </li>
<li>Hook 函数必须以 “use” 命名开头</li>
<li>利用 useState 创建 Redux</li>
<li>利用 useEffect 代替一些生命周期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">// template</div><div class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</div><div class="line"></div><div class="line">// 底层 Hooks, 返回布尔值：是否在线</div><div class="line">function useFriendStatusBoolean(friendID) &#123;</div><div class="line">  const [isOnline, setIsOnline] = useState(null);</div><div class="line"></div><div class="line">  function handleStatusChange(status) &#123;</div><div class="line">    setIsOnline(status.isOnline);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  useEffect(() =&gt; &#123;</div><div class="line">    API.subscribeToFriendStatus(friendID, handleStatusChange);</div><div class="line">    return () =&gt; &#123;</div><div class="line">      API.unsubscribeFromFriendStatus(friendID, handleStatusChange);</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  return isOnline;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 上层 Hooks，根据在线状态返回字符串：Loading... or Online or Offline</div><div class="line">function useFriendStatusString(props) &#123;</div><div class="line">  const isOnline = useFriendStatusBoolean(props.friend.id);</div><div class="line"></div><div class="line">  if (isOnline === null) &#123;</div><div class="line">    return &quot;Loading...&quot;;</div><div class="line">  &#125;</div><div class="line">  return isOnline ? &quot;Online&quot; : &quot;Offline&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用了底层 Hooks 的 UI</div><div class="line">function FriendListItem(props) &#123;</div><div class="line">  const isOnline = useFriendStatusBoolean(props.friend.id);</div><div class="line"></div><div class="line">  return (</div><div class="line">    &lt;li style=&#123;&#123; color: isOnline ? &quot;green&quot; : &quot;black&quot; &#125;&#125;&gt;&#123;props.friend.name&#125;&lt;/li&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用了上层 Hooks 的 UI</div><div class="line">function FriendListStatus(props) &#123;</div><div class="line">  const statu = useFriendStatusString(props.friend.id);</div><div class="line"></div><div class="line">  return &lt;li&gt;&#123;statu&#125;&lt;/li&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>只在 React 函数最顶层使用 Hooks </li>
</ul>
<p>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们，详见<a href="https://reactjs.org/docs/hooks-rules.html#explanation" target="_blank" rel="external">官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本规则&quot;&gt;&lt;a href=&quot;#基本规则&quot; class=&quot;headerlink&quot; title=&quot;基本规则&quot;&gt;&lt;/a&gt;基本规则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个文件只包含一个 React 类组件 &lt;ul&gt;
&lt;li&gt;但是多个函数式组件可以放到一个文件中，eslint: react/no-multi-comp&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果使用 JavaScript，则文件扩展名为 .jsx；如果使用 TypeScript，则文件扩展名为 .tsx&lt;/li&gt;
&lt;li&gt;除非是在非 JSX 文件中初始化应用，否则不要使用 React.createElement&lt;/li&gt;
&lt;li&gt;只允许使用 Class Component 和 Functional Component 两种形态来书写组件，建议尽量使用函数式组件配合 Hooks 来进行开发，没有state的组件生命为函数组件。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="规范" scheme="https://guohenkai.github.io/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="规范" scheme="https://guohenkai.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
</feed>
